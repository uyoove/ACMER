# [ç®—æ³•æ€»ç»“]()

[**ç‰¹åˆ«ç¯‡**](#tbp)           		[**åŸºç¡€ç¯‡**](#jcp)         		 [**æ€ç»´æŠ€å·§ç¯‡**](#swjqp)         		**[å›¾è®ºç¯‡](#trp)**         		 [**æ•°æ®ç»“æ„ç¯‡**](#sjjgp)       

â€‹								[**å­—ç¬¦ä¸²ç¯‡**](#zfcp)               [**åšå¼ˆç¯‡**](#byp)                  [**ç»„åˆæ•°å­¦ç¯‡**](#zhsxp)

[**æœ¬äººä»£ç æ¨¡ç‰ˆ**](#brdmmb)                                       [**æ•°è®ºç¯‡**](#srp)                                                     [**æ¯”èµ›æ€»ç»“**](#bszj)

## å°ç»“è®º&æŠ€å·§

### 1.æ•°å­¦

**1.å“¥å¾·å·´èµ«çŒœæƒ³**

â€‹	ä¸€ä¸ªå¶æ•°ä¸€å®šèƒ½åˆ†æˆä¸¤ä¸ªè´¨æ•°ä¹‹å’Œ

**ä¾‹é¢˜:**CF735D

**2.ä¸€ç§æ•°å­¦çš„è´ªå¿ƒæƒ³æ³•**

â€‹	oè·³cntæ­¥åˆ°x å¯ä»¥æ­£è´Ÿè·³,é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å…ˆä¸€ç›´å¾€ç›®æ ‡æ–¹å‘è·³ç›´åˆ°è·³åˆ°æˆ–è€…è·³è¿‡,è·³è¿‡æˆ‘ä»¬å¯ä»¥åæ‚”è´ªå¿ƒ (y-x)/2è¿™ä¸€æ­¥æˆ‘ä»¬å¯ä»¥åæ‚”æ‰€ä»¥å¦‚æœ(y-x)æ˜¯å¶æ•°å’Œè·³åˆ°è¯¥ç‚¹çš„æ­¥æ•°ä¸€æ ·çš„,å¥‡æ•°å°±ç»§ç»­è·³

**ä¾‹é¢˜:**CF11B

**3.æœŸæœ›å‰ç¼€æ€§**

å¦‚æœæœ‰næ¬¡æƒ…å†µ,æœ‰ä¸€ä¸ªäº‹ä»¶ä¸ºk å¦‚ç”©å­äº‹ä»¶,é‚£ä¹ˆæƒ…å†µå…±æœ‰  k^n - (k-1)^n ç§;

è‹¥*n*æ¬¡æŠ•æ·çš„ç‚¹æ•°éƒ½åœ¨1åˆ°*k*å†…ï¼Œå…±æœ‰ğ‘˜^nç§æƒ…å†µã€‚

è‹¥*n*æ¬¡æŠ•æ·çš„ç‚¹æ•°éƒ½åœ¨1åˆ°kâˆ’1å†…ï¼Œå…±æœ‰(k-1)^nç§æƒ…å†µã€‚

æ‰€ä»¥å‘ç”Ÿkå°±æ˜¯k^n - (k-1)^n ç§;

**4.ä¹˜é˜¶æ€§** 

(i+1)ä¸ª i ! = (i+1)!;

å› ä¸º (i+1)*i! = (i+1)! 

**5.lcmç‰¹æ€§**

å¦‚æœæˆ‘ä»¬æœ‰ä¸¤ä¸ªæ•´æ•°nå’Œm*(*n*>m*)ï¼Œå®ƒä»¬çš„æœ€å¤§å…¬çº¦æ•°ä¸ºkï¼Œåˆ™kå¿…ç„¶n*âˆ’*mçš„çº¦æ•°

ç›¸é‚»çš„ä¸¤ä¸ªæ•°å¿…å®šäº’è´¨(å·®ä¸º1ï¼‰ï¼Œå½“ä¸€ä¸ªæ•°*n*ä¸ºå¥‡æ•°æ—¶nå’Œnâˆ’2å¿…å®šäº’è´¨

**6.gcdç‰¹æ€§**

gcd(*x*,*y*)=gcd(*x*,*y*âˆ’*x*) (*x*<*y*)

æ¨å¹¿ä¸€ä¸‹ï¼š

gcdâ¡(ğ‘1,ğ‘2,ğ‘3,ğ‘4,ğ‘5,...,ğ‘ğ‘›)

=gcdâ¡(ğ‘1,ğ‘2âˆ’ğ‘1,ğ‘3âˆ’ğ‘2,ğ‘4âˆ’ğ‘3,ğ‘5âˆ’ğ‘4,...,ğ‘ğ‘›âˆ’ğ‘ğ‘›âˆ’1)

![image-20240526200521222](img/image-20240526200521222.png)

**7.çŸ©é˜µåˆ‡å‰²**

æœ‰ä¸€å— ğ‘¤Ã—â„ çš„ç»ç’ƒï¼Œæ¯æ¬¡æ¨ªç€åˆ‡ä¸€åˆ€ (ğ»)æˆ–è€…ç«–ç€åˆ‡ä¸€åˆ€ (ğ‘‰) ï¼Œæ²¡æœ‰ä¸¤æ¬¡ç›¸åŒçš„åˆ‡å‰²ï¼Œæ±‚æœ€å¤§çš„çŸ©å½¢ç¢ç‰‡é¢ç§¯ã€‚

**æ˜¾ç„¶ï¼Œæœ€å¤§çŸ©å½¢ç¢ç‰‡é¢ç§¯ == æœ€å¤§çš„é•¿ Ã— æœ€å¤§çš„å®½ã€‚å› ä¸ºé•¿å®½äº’ä¸å¹²æ‰°ï¼Œæ‰€ä»¥æˆ‘ä»¬åˆ†å¼€å¤„ç†ã€‚**



### 2.æ ‘ä¸Šé—®é¢˜

1.å¦‚æœç®—æ ‘çš„è´¡çŒ®é‚£ä¹ˆæˆ‘ä»¬å°±è¦æƒ³æ¯ä¸ªèŠ‚ç‚¹æ”¹å˜å¯¹ç­”æ¡ˆçš„å¢åŠ ä¸å¯¹ä¸‹æ•°æˆ–è€…ä¸Šæ ‘çš„å½±å“

2.æ ‘ä¸Šçš„é‡å¿ƒè‡³å°‘1è‡³å¤š2

3.å®šä¹‰ ğ‘‘ğ‘–ğ‘ [u] è¡¨ç¤ºèŠ‚ç‚¹ ğ‘¢ åˆ°æ ¹èŠ‚ç‚¹çš„è·ç¦» æ ‘ä¸Šä»»æ„ä¸¤ç‚¹ u,v çš„ç®€å•è·¯å¾„å’Œç­‰äº dis[u]+dis[v]âˆ’2Ã—dis[lca(u,v)]

å¯ä»¥ç­‰ä»·è½¬æ¢ä¸ºè¾¹æƒå€¼

### 3.å›¾ä¸Šé—®é¢˜

æ±‚ä¸€ä¸ªå›¾ å¯¹äºæ²¡æœ‰è¿è¾¹çš„è¾¹è¿›è¡Œè¿è¾¹ä¸å½±å“æœ€çŸ­è·¯çš„è¾¹çš„æ•°é‡,:

è®¾sä¸ºèµ·ç‚¹ tä¸ºç»ˆç‚¹ xä¸ºä¸€ä¸ªç‚¹ yä¸ºä¸€ä¸ªç‚¹ xä¸yä¸€å¼€å§‹ä¸ç›¸è¿æ¥

å¦‚æœxè¿yä¸å½±å“æœ€çŸ­è·¯é‚£ä¹ˆ dis[s] [x] + dis[y] [t] + 1 <= dis[s] [t] (åŠ ä¸€æ˜¯å› ä¸ºåŠ ä¸€æ¡è¾¹,è¾¹æƒå€¼ä¸º1) 

## <a name ="tbp">**ç‰¹åˆ«ç¯‡(åŠ¨æ€è§„åˆ’ä»å”¯å”¯è¯ºè¯ºåˆ°é‡æ‹³å‡ºå‡»):**</a>

**æœ¬ç« ä¸»è¦ç§¯æ”’å„ç±»dpçš„ æ¨¡å‹,ä»¥åŠç»éªŒ**

### 1.çº¿æ€§DP

#### æ±‚åºåˆ—ä½ç½®æ˜¯å¦åˆæ³•

##### CF1741E

**é¢˜ç›®å¤§æ„ï¼šç»™å®šä¸€ä¸ªåºåˆ— *b*ï¼Œé—®åºåˆ— bæœ‰æ²¡æœ‰å¯èƒ½æ˜¯ä»»æ„ä¸€ä¸ªåºåˆ— aé€šè¿‡ä¸‹åˆ—æ–¹å¼å¾—å‡ºæ¥çš„ï¼š**

1. **å°†åºåˆ— a åˆ†æˆè‹¥å¹²æ®µ**
2. **å°†æ¯ä¸€æ®µçš„æ®µé•¿æ’å…¥åˆ°è¯¥æ®µçš„å·¦è¾¹æˆ–è€…å³è¾¹**

**æ¯”å¦‚è¯´ bä¸º112313223**

**å¯ä»¥åˆ†æˆa 1 231 23**

**1 ä¸€ä¸ªå­—ç¬¦1 231 ä¸‰ä¸ªå­—ç¬¦3 ä¸¤ä¸ªå­—ç¬¦2 23;**

è¿™æ˜¯ä¸€ä¸ªåˆ¤æ–­ä½ç½®åˆæ³•æ€§çš„dp

dpiè¡¨ç¤º 1,iæ˜¯å¦åˆæ³•

è®¾å½“å‰ä½ç½®aiæ˜¯åŒºé—´é•¿åº¦çš„å€¼,å¯ä»¥åˆæ³•é€’æ¨

1.è‹¥ä»–è¡¨ç¤ºåŒºé—´å·¦è¾¹ åˆ™[1,i+ai]åˆæ³•çš„å……åˆ†æ¡ä»¶æ˜¯[1,i-1]åˆæ³•

2.è‹¥å®ƒåœ¨æ‰€è¡¨ç¤ºåŒºé—´çš„å³è¾¹,åˆ™[1,i]åˆæ³•çš„å……åˆ†æ¡ä»¶æ˜¯[1,i-ai-1];

ä¸¤è€…åˆæ³•ä¸€ä¸ªå³å¯

**æ–¹ç¨‹:**

**dp[i + a[i]] |= dp[i-1];**

**dp[i] |= dp[i - 1 - a[i]];**

##### CF788A

é¢˜ç›®å¤§æ„:

ç»™ä½ ä¸€ä¸²æ•°ç»„,è®©ä½ æ±‚ä¸€ä¸ªåŒºé—´æ»¡è¶³ä»¥ä¸‹å…¬å¼çš„æœ€å¤§å€¼:



![image-20240212194237106](img/image-20240212194237106.png)

æ€è·¯:

å› ä¸º-1,1æ˜¯æ ¹æ®lå¾…å®š

å‰ä¸€ä¸ªæ˜¯-1 è¿™ä¸€ä¸ªå¿…å®šæ˜¯1

å‰ä¸€ä¸ªæ˜¯1 è¿™ä¸€ä¸ªå¿…å®šæ˜¯-1

æ‰€ä»¥æˆ‘ä»¬dpå¯ä»¥è®¾ç½®ä¸º

dp[n] [2] è¡¨ç¤ºå‰iä¸ªæ•°+ æˆ–è€… -çš„æœ€å¤§å€¼

ç±»ä¼¼æœ€é•¿ä¸Šå‡åºåˆ—é—®é¢˜

**æ–¹ç¨‹:**

**æˆ‘ä»¬å®šä¹‰1ä¸º- 0ä¸º+;**

**é¢„å¤„ç†p[i] = abs(a[i] - a[i+1]);**

**dp[i] [1] = max(dp[i - 1] [0] + p[i],p[i]);**

**dp[i] [0] = max(dp[i - 1] [1] - p[i],0);**

##### CF192C

**é¢˜ç›®å¤§æ„:**

æœ‰ä¸€ä¸ªç‹æœï¼Œä»–ä»¬å›½ç‹çš„åå­—ç”¨å§“æ°çš„ç®€å†™æ¥æ ‡è®°æ¯ä¸€ä»£ã€‚

ä¸ºäº†ä¿è¯ç‹æœçš„ç¨³å®šï¼Œç°åœ¨è¿™ä¸ªç‹æœçš„ç»§æ‰¿äººçš„åå­—éœ€è¦æ»¡è¶³

ç»§æ‰¿è€…åå­—çš„ç¬¬ä¸€ä¸ªå­—æ¯è¦å’Œå‰ä»£åå­—æœ€åä¸€ä¸ªå­—æ¯ç›¸åŒã€‚

ç„¶åæ‹¼æ¥èµ·æ¥çš„åå­—ï¼Œç¬¬ä¸€ä¸ªå­—æ¯å’Œæœ€åä¸€ä¸ªå­—æ¯ç›¸åŒã€‚

ç°åœ¨æœ‰ä¸€ä¸ªè€ƒå¤åšå£«ï¼ŒçŸ¥é“äº†è¿™ä¸ªç‹æœå›½ç‹å’Œäº²æˆšçš„åå­—ã€‚é—®ä½ è¿™ä¸ªç‹æœæ‰€èƒ½å¤Ÿå¾—åˆ°çš„æœ€é•¿å­—ç¬¦ä¸²ã€‚
**æ€è·¯:**

å› ä¸ºæœ€åä¸€ä¸ªçš„å°¾å­—æ¯ç­‰äºç¬¬ä¸€ä¸ªçš„é¦–å­—æ¯,ä½†æ˜¯æˆ‘ä»¬ä¸çŸ¥é“å“ªä¸€ä¸ªå­—æ¯åšè¿™ä¸ªé¦–å’Œå°¾

å› ä¸ºä¸€å…±å°±26ä¸ªå­—æ¯,æˆ‘ä»¬æšä¸¾å³å¯

è®¾dp[x] [y] ä¸º å­—æ¯xå¼€å¤´ å­—æ¯yç»“å°¾ çš„æœ€å¤§è¿æ¥é•¿åº¦

æˆ‘ä»¬è·å–å½“å‰string çš„ å¤´è®¾ä¸ºu å°¾è®¾ä¸ºv

æšä¸¾æ¯ä¸€ä¸ªj

å¦‚æ­¤

**è½¬ç§»æ–¹ç¨‹ä¸º: dp[j] [v] = max(dp[j] [v],dp[ j ] [u] + s.size()) ** æœ‰ç‚¹åƒæœ€çŸ­è·¯çš„å‘³é“

**ä»£ç :**

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int,int>
#define endl "\n"
typedef unsigned long long ULL;
typedef long long ll;
#define rep(i, a, b) for (int i = ll(a); i <= ll(b); ++i)
const int N = 200005;
//ä¸è¦æŠŠé¢˜ç›®æƒ³çš„å¤ªéš¾

void solve(){
	int n;
	cin >> n;
	int dp[26][26];
	memset(dp,0,sizeof dp);
	int ma = 0;
	for(int i = 0; i < n; i++){
		string s;
		cin >> s;
		int u = s[0] - 'a';
		int v = s[s.size() - 1] - 'a';
		int len = s.size();
		for(int j = 0; j < 26;j++){
			if(dp[j][u] == 0) continue;
			dp[j][v] = max(dp[j][v],dp[j][u] + len);
		}
		dp[u][v] = max(len,dp[u][v]);
	}
	for(int i = 0; i < 26;i++)ma=max(dp[i][i],ma);
	cout <<ma << endl;

}

signed main(){
	std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    std::cout.tie(0);
	int times = 1;
	//cin >> times;
	while(times--){
		solve();
	}
	return 0;
}
```



##### NOIP2012

[[NOIP2012 æ™®åŠç»„\] æ‘†èŠ± - StarryCoding | è¸å‡ºç¼–ç¨‹ç¬¬ä¸€æ­¥](https://www.starrycoding.com/problem/80)

```c++
void solve(){
	int n,m;
	cin >> n >> m;
	int a[n+1];
	for(int i = 1; i <= n;i++) cin >> a[i];
	int dp[n + 1][m+1];//dp[i][j]è¡¨ç¤ºåˆ°ç¬¬iç›†èŠ±ä¸ºæ­¢,é€‰iç›†èŠ±çš„ç»„åˆæ•°
	// dp[i][j] = dp[i-1][j - k];
	memset(dp,0,sizeof dp);
	dp[0][0] = 1;
	for(int i = 1; i <= n; i++){
		for(int j = 0; j <= m;j++){
			for(int k = 0; k <= min(a[i],j); k++){
				dp[i][j] = (dp[i][j] + dp[i-1][j-k]);
			}
		}
	}
	cout << dp[n][m] << endl;

}
```

##### æ±‚æœ€å¤§æ­£æ–¹å½¢dp

dp[i] [j] è¡¨ç¤ºå³ä¸‹è§’åæ ‡ä¸º(i,j)çš„æ­£æ–¹å½¢çš„æœ€å¤§é•¿åº¦

dp[i] [j] = min(dp[i - 1] [j - 1],dp[i - 1] [ j ],dp[i] [j - 1]);



### 2.å­—ç¬¦ä¸²ç±»å‹DP

#### åŠ›æ‰£2262

**é¢˜ç›®ç±»å‹:**å­—ç¬¦ä¸²+è´¡çŒ®+dp

[2262. å­—ç¬¦ä¸²çš„æ€»å¼•åŠ› - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/total-appeal-of-a-string/description/)

å­—ç¬¦ä¸²çš„ **å¼•åŠ›** å®šä¹‰ä¸ºï¼šå­—ç¬¦ä¸²ä¸­ **ä¸åŒ** å­—ç¬¦çš„æ•°é‡ã€‚

- ä¾‹å¦‚ï¼Œ`"abbca"` çš„å¼•åŠ›ä¸º `3` ï¼Œå› ä¸ºå…¶ä¸­æœ‰ `3` ä¸ªä¸åŒå­—ç¬¦ `'a'`ã€`'b'` å’Œ `'c'` ã€‚

ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² `s` ï¼Œè¿”å› **å…¶æ‰€æœ‰å­å­—ç¬¦ä¸²çš„æ€»å¼•åŠ›** **ã€‚**

**å­å­—ç¬¦ä¸²** å®šä¹‰ä¸ºï¼šå­—ç¬¦ä¸²ä¸­çš„ä¸€ä¸ªè¿ç»­å­—ç¬¦åºåˆ—ã€‚

**ç¤ºä¾‹ 1ï¼š**

```
è¾“å…¥ï¼šs = "abbca"
è¾“å‡ºï¼š28
è§£é‡Šï¼š"abbca" çš„å­å­—ç¬¦ä¸²æœ‰ï¼š
- é•¿åº¦ä¸º 1 çš„å­å­—ç¬¦ä¸²ï¼š"a"ã€"b"ã€"b"ã€"c"ã€"a" çš„å¼•åŠ›åˆ†åˆ«ä¸º 1ã€1ã€1ã€1ã€1ï¼Œæ€»å’Œä¸º 5 ã€‚
- é•¿åº¦ä¸º 2 çš„å­å­—ç¬¦ä¸²ï¼š"ab"ã€"bb"ã€"bc"ã€"ca" çš„å¼•åŠ›åˆ†åˆ«ä¸º 2ã€1ã€2ã€2 ï¼Œæ€»å’Œä¸º 7 ã€‚
- é•¿åº¦ä¸º 3 çš„å­å­—ç¬¦ä¸²ï¼š"abb"ã€"bbc"ã€"bca" çš„å¼•åŠ›åˆ†åˆ«ä¸º 2ã€2ã€3 ï¼Œæ€»å’Œä¸º 7 ã€‚
- é•¿åº¦ä¸º 4 çš„å­å­—ç¬¦ä¸²ï¼š"abbc"ã€"bbca" çš„å¼•åŠ›åˆ†åˆ«ä¸º 3ã€3 ï¼Œæ€»å’Œä¸º 6 ã€‚
- é•¿åº¦ä¸º 5 çš„å­å­—ç¬¦ä¸²ï¼š"abbca" çš„å¼•åŠ›ä¸º 3 ï¼Œæ€»å’Œä¸º 3 ã€‚
å¼•åŠ›æ€»å’Œä¸º 5 + 7 + 7 + 6 + 3 = 28 ã€‚
```

**æ€è€ƒ:**

1.å°†**æ‰€æœ‰å­ä¸²**æŒ‰ç…§å…¶æœ«å°¾å­—ç¬¦çš„ä¸‹æ ‡åˆ†ç»„ã€‚

2.è€ƒè™‘ä¸¤ç»„**ç›¸é‚»**çš„å­ä¸²ï¼šä»¥ s[iâˆ’1] ç»“å°¾çš„å­ä¸²ã€ä»¥ s[i] ç»“å°¾çš„å­ä¸²ã€‚

3.ä»¥ s[i] ç»“å°¾çš„å­ä¸²ï¼Œå¯ä»¥çœ‹æˆæ˜¯ä»¥ s[iâˆ’1]ç»“å°¾çš„å­ä¸²ï¼Œåœ¨æœ«å°¾æ·»åŠ ä¸Š s[i] ç»„æˆã€‚

**ä¸Šé¢è¿™ä¸€ä¸²æç¤ºæ˜¯æ€è€ƒå­ä¸²ç»Ÿè®¡ç±»é—®é¢˜çš„é€šç”¨æŠ€å·§ä¹‹ä¸€ã€‚**

**ä»£ç :**

```c++
class Solution {
public:
    long long appealSum(string s) {
        int cnt[26];
        memset(cnt,-1,sizeof cnt);
        int n = s.size();
        long long ans = 0;
        int sum = 0;
        for(int i = 0; i < n;i++){
            sum+=1;
            if(cnt[s[i] - 'a'] == -1){
                sum+=i;
            }else{
                sum+=i-cnt[s[i] - 'a']-1;
            }
            ans+=sum;
            cnt[s[i] - 'a'] = i;
        }
        return ans;
    }
};
```

### 3.æ•°ä½DP

**ä»€ä¹ˆæ˜¯æ•°ä½dp**
æ•°ä½dpæ˜¯ä¸€ç§è®¡æ•°ç”¨çš„dpï¼Œä¸€èˆ¬æ˜¯è¦ç»Ÿè®¡ä¸€ä¸ªåŒºçº§[l,r]å†…æ»¡è¶³ä¸€äº›æ¡ä»¶çš„æ•°çš„ä¸ªæ•°

æ‰€è°“æ•°ä½dpï¼Œå°±æ˜¯å¯¹æ•°ä½è¿›è¡Œdpï¼Œä¹Ÿå°±æ˜¯ä¸ªä½ã€åä½ç­‰

ç›¸å¯¹äºæ™®é€šçš„æš´åŠ›æšä¸¾ï¼Œæ•°ä½dpå¿«å°±å¿«åœ¨å®ƒçš„è®°å¿†åŒ–ï¼Œä¹Ÿå°±æ˜¯è¯´åé¢å¯èƒ½ä¼šåˆ©ç”¨åˆ°å‰é¢å·²ç»è®¡ç®—å¥½çš„ä¸œè¥¿ï¼Œæ¯”å¦‚æˆ‘ä»¬ç°åœ¨è¦è®¡ç®—å½¢å¼ä¸º2xxxxçš„æ»¡è¶³æŸäº›æ¡ä»¶çš„æ•°å­—çš„ä¸ªæ•°ï¼Œè€Œè¿™ä¸ªä¿¡æ¯æˆ‘ä»¬å¯èƒ½å¯ä»¥åˆ©ç”¨è®¡ç®—1xxxxæ—¶é—ç•™ä¸‹æ¥çš„ä¿¡æ¯ï¼Œä»è€Œè¾¾åˆ°ä¸€ä¸ªé¿å…é‡å¤è®¡ç®—çš„æ•ˆæœï¼Œå› æ­¤å¯ä»¥é™ä½æ—¶é—´å¤æ‚åº¦

**æ¨¡ç‰ˆä»£ç :**

```c++
typedef long long ll;
vector<int> a;
ll dp[20][state];   //ä¸åŒé—®é¢˜æ•°ç»„çš„ç»´åº¦å¯èƒ½ä¸åŒï¼Œçœ‹å…·ä½“é¢˜ç›®çš„æ¡ä»¶
ll dfs(int pos,int state,bool lead,bool limit)  //è¿™é‡Œçš„stateå¯èƒ½æœ‰å¤šä¸ªï¼Œçœ‹å…·ä½“é¢˜ç›®
{
    if(pos==n)      //næ˜¯æ•°ç»„çš„é•¿åº¦ï¼Œä»é«˜ä½åˆ°åœ°ä½æ˜¯0-n-1
        return 1;   //è¿”å›å€¼çœ‹å…·ä½“æƒ…å†µ
    if(!limint && !lead && dp[pos][state]!=-1)
        return dp[pos][state];
    int up = limit?a[pos]:9;    
    ll ans = 0;
    for(int i=0;i<=up;i++)
    {
        //è¿™é‡Œè¿˜å¯èƒ½æœ‰ä¸€äº›ifä¹‹ç±»çš„åˆ¤æ–­è¯­å¥
        ans += dfs(pos+1,state(çŠ¶æ€è½¬ç§»),lead&&i==0,limit&&i==a[pos])
    }
    if(!limit && !lead)
        dp[pos][state] = ans;
    return ans;
}
ll solve(ll x)
{
    int pos = 0;
    while(x)
    {
        a[pos++] = x%10;
        x /= 10;
    }
    reverse(a.begin(),a.end());
    return dfs(0,state,true,true);
}
```

#### åŠ›æ‰£788

[788. æ—‹è½¬æ•°å­— - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/rotated-digits/description/)

```c++
class Solution {
public:
    int rotatedDigits(int n) {
       vector<int> f = {1,1,2,0,0,2,2,0,1,2};
       vector<int> v;
       while(n) v.push_back(n%10),n/=10;
       reverse(v.begin(),v.end());
       int len = v.size();
       int dp[len + 1][2];
       memset(dp,-1,sizeof dp);
       function<int(int,int,int)> dfs = [&](int pos,int state,int limit)->int{
           if(pos==len) return state;
           if(dp[pos][state]!=-1 && !limit) return dp[pos][state];
           int up = limit ? v[pos] : 9;
           int sum = 0;
           for(int i = 0;i <= up;i++){
               if(f[i]==0) continue;
               sum += dfs(pos+1,state || f[i] == 2,limit&&i==v[pos]);
           }
           if(!limit){
               dp[pos][state] = sum;
           }
           return sum;
       };
       return dfs(0,0,1);
    }
};
```

#### åŠ›æ‰£2376

[2376. ç»Ÿè®¡ç‰¹æ®Šæ•´æ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/count-special-integers/description/)

```c++
class Solution {
public:
    int countSpecialNumbers(int n) {
        vector<int> v;
        while(n){
            v.push_back(n%10);
            n/=10;
        }
        int len = v.size();
        reverse(v.begin(),v.end());
        int dp[len + 1][1 << 10];
        memset(dp,-1,sizeof dp);
        function<int(int,int,int,int)> dfs = [&](int pos,int mask,int limit,int zero)->int{
            if(pos==len) return zero;
            if(dp[pos][mask] != -1 && zero && !limit) return dp[pos][mask];
            int sum = 0;
            if(!zero){
                sum += dfs(pos+1,mask,false,false);
            }
            int up = limit ? v[pos] : 9;
            for(int i = 1-zero; i <= up; i++){
                if(((mask >> i) & 1) == 0){
                    sum += dfs(pos+1,mask|(1<<i),limit&&v[pos]==i,true);
                }
            }
            if(!limit && zero) dp[pos][mask] = sum;
            return sum;
        };
        return dfs(0,0,1,false);
    }
};
```

#### åŠ›æ‰£1012

[1012. è‡³å°‘æœ‰ 1 ä½é‡å¤çš„æ•°å­— - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/numbers-with-repeated-digits/)

æ­£éš¾åˆ™å,å¦‚è¦æ±‚æœ‰é‡å¤æ•°å­—çš„,ä¸å¦‚æ±‚æ²¡æœ‰é‡å¤æ•°å­—çš„æœ€åç­”æ¡ˆn-dfs();å‰©ä¸‹çš„å³æ˜¯ç­”æ¡ˆ

ä»£ç :

```c++
class Solution {
public:
    int numDupDigitsAtMostN(int n) {
        vector<int> nums;
        int t = n;
        while(n){
            nums.push_back(n%10);
            n/=10;
        }
        reverse(nums.begin(),nums.end());
        int len = nums.size();
        int dp[len+1][1<<11];
        memset(dp,-1,sizeof dp);
        function<int(int,int,int,int)> dfs = [&](int pos,int mask,int limit,int nzero) ->int{
            if(pos==len) return nzero;
            if(nzero && !limit &&dp[pos][mask]!=-1) return dp[pos][mask];
            int sum = 0;
            int up = limit ? nums[pos] : 9;
            if(!nzero){
                sum += dfs(pos+1,mask,0,0);
            }
            for(int i = 1-nzero; i <= up;i++){
                    if(((mask >> i) & 1)==0) sum += dfs(pos+1,(mask|(1 << i)),limit&&nums[pos]==i,1);
                   
            }
            if(!limit&&nzero) dp[pos][mask] = sum;
            return sum;
        };
        return t - dfs(0,0,1,0);
    }
};
```

#### BD201722

Vå­—å½¢æ•° éå±±å³°

```c++
#include<bits/stdc++.h> 
using namespace std;
#define int long long
int a[101];
 string s;
 int n;
 int dp[101][11][3];
 const int MOD = 1e9+7;
int dfs(int pos,int pre,int state,int lead,int limit){
    if(pos <= -1) return lead;
    if(lead && !limit && dp[pos][pre][state] != -1) return dp[pos][pre][state];
    int res = 0;
    int up = (limit == 1 ? a[pos] : 9);
    if(lead == 0)  res=(res+ dfs(pos - 1,pre,state,0,0))%MOD;
    for(int i = 1-lead;i <= up;i++){
        if(i > pre){
            res =(res+ dfs(pos - 1,i,1,1,limit && i == up) )%MOD;
        }else if(i == pre){
             res =(res+ dfs(pos - 1,i,state,1,limit && i == up))%MOD;
        }else{
            if(state != 1){
                res =(res+ dfs(pos - 1,i,2,1,limit && i == up))%MOD;
            }
        }
    }
    if(lead && !limit) dp[pos][pre][state] = res;
    return res;
}
void solve(){
   memset(a,0,sizeof a);
    cin >> s;
    n = s.size();
    int len = 0;
    for(int i = n - 1; i >= 0 ;i--){
        a[len++] = s[i] - 48;
    }
    memset(dp,-1,sizeof dp);
    cout << dfs(n - 1,10,2,0,1) << endl;
}
signed main( )
{
    int t;
    cin >> t;
    while(t--) solve();
    return 0;
}
```



### 4.æ ‘å½¢DP

#### CF219D

æ¢æ ¹dp

[Problem - 219D - Codeforces](https://codeforces.com/problemset/problem/219/D)

**ä»£ç :**

```c++
const int N = 200005;
//ä¸è¦æŠŠé¢˜ç›®æƒ³çš„å¤ªéš¾
int n;
vector<vector<PII>> edge(N);
int f[N];
int dfs(int node,int fa){
	int sum = 0;
	for(auto [k,v]:edge[node]){
		if(k!=fa){
			sum += dfs(k,node) + v;
		}
	}
	f[node] = sum;
	return sum;
}
//æ¢æ ¹dp
void dfs1(int node,int fa){
	for(auto [k,v]:edge[node]){
		if(k==fa) continue;
		if(v>0){
			f[k] = f[node] - 1;
		}else{
			f[k] = f[node] +1;
		}
		dfs1(k,node);
	}
}
void solve(){
	memset(f,0x3f,sizeof f);
	cin >> n;
	for(int i = 0; i < n - 1; i++){
		int u,v;
		cin >> u >> v;
		edge[u].push_back({v,0});
		edge[v].push_back({u,1});
	}
	dfs(1,-1);
	dfs1(1,-1);
	int mi = 0x3f3f3f3f;
	 for(int i = 1; i <= n;i++){
	 	mi = min(mi,f[i]);
	}

	cout << mi << endl;	
	for(int i = 1; i <= n;i++){
		if(f[i]==mi) cout << i << " ";
	}
}
```

####  CF1324F

æ¢æ ¹DP

```c++
const int N = 200005;
//ä¸è¦æŠŠé¢˜ç›®æƒ³çš„å¤ªéš¾
int n;
int f[N];
int color[N];
vector<vector<int>> edge(N);
void dfs(int node,int fa){
	f[node] = (color[node] == 1 ? 1:-1);
	for(auto p: edge[node]){
		if(p==fa) continue;
		dfs(p,node);
		if(f[p]>0) f[node] += f[p];
	}
}
void dfs2(int node,int fa){
	for(auto v:edge[node]){
		if(v==fa) continue;
		int a = f[node],b = f[v];
		if(b>0) a-=b;
		if(a>0) b+=a;
		f[v] = b;
		dfs2(v,node);
	}
}
void solve(){
	memset(f,0,sizeof f);
	cin >> n;
	for(int i = 1; i <= n;i++) cin >> color[i];
	for(int i = 1; i < n; i ++){
		int u,v;
		cin >> u >> v;
		edge[u].push_back(v);
		edge[v].push_back(u);
	}
	dfs(1,-1);
	dfs2(1,-1);
	for(int i = 1; i <= n;i++) {
		cout << f[i] << " ";
	}
}
```

#### åŠ›æ‰£834

[834. æ ‘ä¸­è·ç¦»ä¹‹å’Œ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/sum-of-distances-in-tree/description/)

```c++
class Solution {
public:
    
    vector<int> sumOfDistancesInTree(int n, vector<vector<int>>& edges) {
        vector<vector<int> > edge(n+1);
        for(auto p:edges){
            int u = p[0],v = p[1];
            edge[u].push_back(v);
            edge[v].push_back(u);
        }
        int f[n+1];
        fill(f,f+n,1);
        vector<int> res(n,0);
        function<void(int,int,int)> dfs = [&](int u,int fa,int dep){
            res[0]+=dep;
            for(auto v:edge[u]){
                if(v==fa) continue;
                dfs(v,u,dep+1);
                //cout << v << " " << f[v] << endl;
                f[u]+=f[v];
            }
        };
        dfs(0,-1,0);
        function<void(int,int)> dfs2 = [&](int u,int fa){
            for(auto v:edge[u]){
                if(v==fa) continue;
                res[v] = res[u] +n - 2*f[v];
                dfs2(v,u);
                
            }
        };
        dfs2(0,-1);
        //cout << f[2];
        return res;
    }
};
```

### 5.åˆ’åˆ†å‹dp

å°†åºåˆ—åˆ†æˆï¼ˆæ°å¥½/è‡³å¤šï¼‰*k* ä¸ªè¿ç»­åŒºé—´ï¼Œæ±‚è§£ä¸è¿™äº›åŒºé—´æœ‰å…³çš„æœ€ä¼˜å€¼ã€‚

é€šå¸¸å®šä¹‰ dp[i] [j] ä¸ºå‰iä¸ªæ•°åˆ’åˆ†æˆ jä¸ªåŒºé—´çš„æœ€ä¼˜å€¼ 

æ—¶é—´å¤æ‚åº¦æœ€åæ˜¯ n^3 å¯æ ¹æ®é¢˜ç›® é€šè¿‡æ¼”å˜å…¬å¼æ¨å¯¼ä¼˜åŒ–dp

#### **åŠ›æ‰£813**

```c++
class Solution {
public:
    double largestSumOfAverages(vector<int>& nums, int k) {
        int n = nums.size();
        double dp[k+1][n+1];
        memset(dp,0,sizeof dp);
        int pre[n+1];
        memset(pre,0,sizeof pre);
        for(int i = 1;i<=n;i++) pre[i] = pre[i-1]+nums[i-1];
        for(int i = 1; i <= k;i++){
            dp[i][i-1] = -0x3f3f3f3f;
            for(int j = i; j <= n-k+i;j++){
                if(i==1){
                    dp[1][j] = pre[j]*1.0/j;
                    continue;
                }
                for(int l = 1; l <= j; l++){
                    dp[i][j] = max(dp[i][j],dp[i - 1][l - 1] + (pre[j]-pre[l-1])*1.0/(j-l+1));
                }

            }
        }
        return dp[k][n];
    }
};
```

#### åŠ›æ‰£2767

```c++
class Solution {
public:
   
    int minimumBeautifulSubstrings(string s) {
        unordered_set<string> f;
        f.insert("1");
        f.insert("101");
        f.insert("11001");
        f.insert("1111101");
        f.insert("1001110001");
        f.insert("110000110101");//12ä½
        f.insert("11110100001001");//14ä½
        int n = s.size();
        s = "&" + s;
        int dp[17][17]; //å‰iä¸ªå­—æ¯åˆ’åˆ†æˆæœ€å°‘ä¸ªjä¸ªæ•°ç»„çš„æœ€å°
        memset(dp,0x3f,sizeof dp);
        for(int i = 1; i <= n;i++){
            dp[i][1] = (f.count(s.substr(1,i)) ? 1: 0x3f3f3f3f);
    
            for(int j = 1; j <= i;j++){
                for(int k = 1; k <= i;k++){
                    dp[i][j] = min(dp[i][j],dp[k - 1][j - 1] + (f.count(s.substr(k,i-k+1)) ? 1: 0x3f3f3f3f));
                    //cout << "i:" <<  i << " j:" << j <<  " k:" << k << " dp[k][j-1]: "<< dp[k][j-1] << " s:" << s.substr(k,i-k+1) << endl;
                }
            }
        }
        int mi = 0x3f3f3f3f;
        for(int i = 1;i<= n;i++){
            mi = min(mi,dp[n][i]);
            //cout << "n:" << n << " i:" << i << " dp[n-1][i]:" << dp[n][i] << endl;
        }
        return mi==0x3f3f3f3f ? -1 : mi;
    }
};
```

#### åŠ›æ‰£1105

```c++
class Solution {
public:
    int minHeightShelves(vector<vector<int>>& books, int shelfWidth) {
        // f[i][j]ä»£è¡¨å‰iä¸ªæ•°åˆ’åˆ†jå±‚çš„æœ€ä¼˜è§£
        // f[i][j] = min(max_h(l,i) + f[l - 1][j - 1],f[i][j]);
        // å¹¶ä¸” ç¬¦åˆ sum[i] - sum[l - 1] <= selfwidth
        int n = books.size();
        int pre[n+1];
        memset(pre,0,sizeof pre);
        for(int i = 1; i <= n;i++){
            pre[i] =pre[i-1]+books[i - 1][0];
        }
        int f[n+1][n+1];
        memset(f,0x3f,sizeof f);
        int h = 0;
        int res = 0x3f3f3f3f;
        for(int i = 1;i<=n;i++){
            h = max(h,books[i - 1][1]);
            f[i][1] = (pre[i]<=shelfWidth ? h : 0x3f3f3f3f);
            res = min(res,f[n][1]);
            for(int j = 2; j <= i; j++){
                int th = 0;
                for(int k = i; k >=1;k--){

                    //cout << i << " " << k << " "<< pre[i] - pre[k - 1] << endl;
                    if(pre[i] - pre[k - 1] > shelfWidth) break;
                    
                    th = max(th,books[k-1][1]);
                    f[i][j] = min(f[i][j],f[k - 1][j - 1] + th);
                    //cout << "i:" << i << " j:" << j << " th:" << th << " k:"<<k << " f[k-1][j - 1]:" << f[k - 1][j-1] << endl;
                }
                if(i==n){
                    res = min(res,f[i][j]);
                }
            }
            
        }
        return res;
    }
};
```

#### åŠ›æ‰£2547

```c++
class Solution {
public:
    int minCost(vector<int>& nums, int k) {
        int n= nums.size();
        int a[n+1];
        for(int i = 1; i <= n;i++){
            a[i] = nums[i - 1];
        }
        int dp[n+1]; //å‰iä¸ªä½ç½®çš„æœ€å°ä»£ä»·
        memset(dp,0x3f,sizeof dp);
        dp[0] = 0;
        for(int i = 1; i <= n;i++){           
            map<int,int> h;
            int cnt = k;
            for(int j = i;j>=1;j--){
                h[a[j]]++;
                if(h[a[j]]==2) cnt+=2;
                if(h[a[j]]>2) cnt++;
                dp[i] = min(dp[j - 1] + cnt,dp[i]);
            }
        }
        return dp[n];
    }
};
```

### 6.çŠ¶å‹DP

#### å°æŠ€å·§:

**ä¸€ä¸ªå¾ˆæ£’çš„æŠ€å·§,æšä¸¾ç¬¬ä¸€ä¸ªå­é›†jæ—¶å€™ä½ æƒ³æšä¸¾ k å¦jä¸€ç›´æ˜¯kçš„å­é›†,ä½ åªéœ€è¦è¿™ä¹ˆåš: **

**for(int k = j; k < mask; k = (k + 1) | j)**

#### åŠ›æ‰£2741

```c++
class Solution {
public:
    int mod = 1e9+7;
    int specialPerm(vector<int>& nums) {
        int n = nums.size();
        int mask = (1<<n) - 1;
        int memo[mask+1][n+1];
        memset(memo,-1,sizeof memo);
        int sum = 0;
        function<int(int,int)> dfs = [&](int mk,int j) ->int{
            int res = 0;
            if(mk == 0) return 1;
            if(memo[mk][j]!=-1) return memo[mk][j];
            for(int i = 0; i < n;i++){
                if((mk >> i)&1){
                    if(nums[i]%nums[j]==0||nums[j]%nums[i]==0){
                        res =(res+ dfs(mk^(1<<i),i))%mod;
                    }
                }
            }
            memo[mk][j] = res;
            return res;
        };
        for(int i = 0; i < n;i++){
            sum = (sum+dfs(mask^(1 << i),i))%mod;
        }
        return sum;
    }
};
```

#### CF1950G

**è®¾ç½®dp[i] [j]ä¸º iè¿™ä¸ªé›†åˆä¸­ä»¥jç»“å°¾çš„æƒ…å†µçš„å¯å¦æ€§,å¾ˆå…¸çš„ä¸€ä¸ªdp,éœ€ç‰¢è®°**

è½¬ç§»æ–¹ç¨‹ ä¸‰é‡å¾ªç¯

dp[i | (1 << j )] [j] |= (dp[i] [k])  (jä¸kç¬¦åˆæ¡ä»¶,ä¸”jä¸åœ¨iä¸­,kåœ¨iä¸­)

#### åŠ›æ‰£526

ç»™å‡ºä¸€ä¸ªçŠ¶æ€å‹ç¼©æ€æƒ³,æšä¸¾ä½ç½®,å¯ä»¥è·å–maskæœ‰å¤šå°‘ä¸ª1ç¡®å®šç°åœ¨ä½ç½®æ˜¯ç¬¬å‡ ä¸ª,å¹¶æšä¸¾,å¯ä»¥ä¼˜åŒ–çŠ¶æ€å‹ç¼©

#### **BD202017**

ç”¨åˆ°è¯¥æŠ€å·§**for(int k = j; k < mask; k = (k + 1) | j)**

```c++
int a[11]; //å°¾å·æ•°é‡
int dp[11][1 << 11 + 1];
int st[1 << 11 + 1]; //å½“å‰å­é›†sä¸‹æœ‰å¤šå°‘è½¦æ˜¯é™åˆ¶çš„
int mask = 1 << 11;
int n;
bool check(int mid){
	//ç¬¬ä¸€å¤©çš„state
	memset(dp,0x3f,sizeof dp);
	for(int i = 0; i < mask;i++){
		dp[1][i] = n - st[i]; 
	}
	for(int i = 2; i <= 5;i++){
		for(int j = 0; j < mask;j++){
			if(dp[i - 1][j] > mid) continue; //ä¿è¯è¿™ä¸ªå­é›†ä¸€å®šæ˜¯ç¬¦åˆè¦æ±‚çš„ <= midçš„
			for(int k = j;k < mask; k = (k + 1) | j){ //ä¼˜åŒ–æšä¸¾ ä¿è¯kä¸ºjçš„å­é›† åšåˆ°ä¸é‡ä¸æ¼
				int tp = n - st[k ^ j];
				if(tp > mid) continue;
				dp[i][k] = min(dp[i][k],tp);
			}
		}
		bool f = 0;
		for(int j = 0; j < mask;j++){
			
			if(dp[i][j] <= mid){
				f = 1;
				break;
			}
		}
		if(!f) return false;
	}
	return true;
}
void solve(){
	memset(a,0,sizeof a);
	cin >> n;
	for(int i = 0; i < n;i++){
		int t;
		cin >> t;
		a[t%10]++;
	}
	for(int i = 0; i < mask;i++){
		st[i] = 0;
		for(int j = 0; j < 10;j++){
			if((i >> j) & 1){
				st[i] += a[j];
			}
		}
	}
	int l = 0,r = n + 1;
	int ans = 0;
	while(l <= r){
		int mid = l +r >> 1;
		if(check(mid)){
			ans = mid;
			r = mid - 1;
		}else{
			l = mid + 1;
		}
	}
	cout << ans << endl;
}
```

#### CF55B

```c++
int a[4];
char t[3];
void solve(){
	for(int i = 0; i < 4;i++){
		cin >> a[i];
	}
	int n =4;
	int dp[1<<5];
	for(int i = 0; i < 3;i++) cin >> t[i];
	memset(dp,0x3f,sizeof dp);
	int mask = (1<<4);
	for(int i = 0; i < 4;i++){
		dp[1 << i] = a[i];
	}
	for(int i = 1;i < mask;i++){
		int cnt = __builtin_popcount(i);
		if(cnt==4) break;
		int mj=0;
		for(int j = 0; j < 4;j++){
			if(!((i >> j)&1)){
				int p = cnt - 1;
				if(t[p] == '+') dp[i | (1<<j)] = min(dp[i | (1<<j)],dp[i]+a[j]);
				else dp[i | (1<<j)] = min(dp[i | (1<<j)],dp[i]*a[j]);
				if(cnt==2){
					if(t[1] == '+') mj +=a[j]; 
					else{
						if(mj == 0) mj = a[j];
						else mj*=a[j];
					}
				}
			}
		}
		if(cnt == 2){
			if(t[2] == '+') dp[mask - 1] = min(dp[mask - 1],mj + dp[i]);
			if(t[2] == '*') dp[mask - 1] = min(dp[mask - 1],mj * dp[i]);
		}
	}	
	cout << dp[mask - 1] << endl;
}
```



## <a name = "jcp">ä¸€ åŸºç¡€ç¯‡</a>

### 1.äºŒåˆ†æŸ¥æ‰¾

**æœ¬äººä½¿ç”¨å·¦å¼€å³é—­åŒºé—´**

**æ—¶é—´å¤æ‚åº¦ O(log n)**

#### **æ¨¡ç‰ˆ**

**1.æœ€å¤§åŒ–**

```c++
int l = 1,r = n - 1;
while(l < r){
    int mid = l+r>>1;
    if(check()) l = mid;
    else r = mid - 1;
}
return mid;
```

**2.æœ€å°åŒ–**

```c++
void solve(){
	cin >> n >> k;
	int l = 1,r = n;
	while(l < r){
		int mid = (l+r)>>1;
		if(check(mid)) r = mid;
		else l = mid + 1;
		//cout << l << " " << r << endl;
	}
	cout << r;
}
```

æœ€å¤§åŒ–å’Œæœ€å°åŒ–èŒƒå›´

#### æ¨¡å‹

è®¡æ•°å‹

æ±‚å’Œå‹

æ˜¯å¦å‹

![](img/1704029064813.png)

### 2.åŠ¨æ€è§„åˆ’

![image-20240208115100197](img/image-20240208115100197.png)

#### 1.èƒŒåŒ…é—®é¢˜

**èƒŒåŒ…é—®é¢˜è§£æ³•ï¼š**
**01 èƒŒåŒ…é—®é¢˜ï¼š**
**å¦‚æœæ˜¯ 01 èƒŒåŒ…ï¼Œå³æ•°ç»„ä¸­çš„å…ƒç´ ä¸å¯é‡å¤ä½¿ç”¨ï¼Œå¤–å¾ªç¯éå† arrsï¼Œå†…å¾ªç¯éå† targetï¼Œä¸”å†…å¾ªç¯å€’åº:**

**å®Œå…¨èƒŒåŒ…é—®é¢˜ï¼š**
**ï¼ˆ1ï¼‰å¦‚æœæ˜¯å®Œå…¨èƒŒåŒ…ï¼Œå³æ•°ç»„ä¸­çš„å…ƒç´ å¯é‡å¤ä½¿ç”¨å¹¶ä¸”ä¸è€ƒè™‘å…ƒç´ ä¹‹é—´é¡ºåºï¼Œarrs æ”¾åœ¨å¤–å¾ªç¯ï¼ˆä¿è¯ arrs æŒ‰é¡ºåºï¼‰ï¼Œtargetåœ¨å†…å¾ªç¯ã€‚ä¸”å†…å¾ªç¯æ­£åºã€‚ ï¼ˆ2ï¼‰å¦‚æœç»„åˆé—®é¢˜éœ€è€ƒè™‘å…ƒç´ ä¹‹é—´çš„é¡ºåºï¼Œéœ€å°† target æ”¾åœ¨å¤–å¾ªç¯ï¼Œå°† arrs æ”¾åœ¨å†…å¾ªç¯ï¼Œä¸”å†…å¾ªç¯æ­£åºã€‚**

ä¾‹é¢˜:https://leetcode.cn/problems/word-break/solutions/744153/yi-tao-kuang-jia-jie-jue-bei-bao-wen-ti-kchg9/?envType=study-plan-v2&envId=top-interview-150

```
01èƒŒåŒ… å¤–å¾ªç¯coin å†…å¾ªç¯ å€’ç€target

å®Œå…¨èƒŒåŒ… å¤–å¾ªç¯coin å†…å¾ªç¯ æ­£ç€target

æˆ– å¤–å¾ªç¯target å†…å¾ªç¯ coin

å¦‚æœè€ƒè™‘ç»„åˆ åˆ™å¤–coinå†…target

å¦‚æœè€ƒè™‘æ’åˆ— åˆ™å¤–targetå†…coin

å¦‚æœæ— æ‰€è°“æ’åˆ—è¿˜å¾—ç»„åˆ æ¯”å¦‚boolæ˜¯å¦å¯ä»¥ æœ€å€¼ç­‰é—®é¢˜ ç”¨å†…å¤–å“ªç§éƒ½å¯ä»¥
```

##### ä¾‹é¢˜:

###### 1.å°çº¢çš„å­é›†å–å

**é¢˜ç›®:**[E-å°çº¢çš„å­é›†å–å_ç‰›å®¢å‘¨èµ› Round 31 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/74362/E)

**é¢˜ç›®å¤§æ„:**å°çº¢æ‹¿åˆ°äº†ä¸€ä¸ªæ•°ç»„ï¼Œå¥¹å‡†å¤‡é€‰æ‹©è‹¥å¹²å…ƒç´ ä¹˜ä»¥ -1ï¼Œä½¿å¾—æœ€ç»ˆæ‰€æœ‰å…ƒç´ çš„å’Œä¸º 0ã€‚å°çº¢æƒ³çŸ¥é“æœ€å°‘éœ€è¦é€‰æ‹©å¤šå°‘ä¸ªå…ƒç´ ï¼Ÿ

**æ€è·¯:**å› ä¸ºæœ€å°‘é€‰å¤šå°‘ä¸ª,æˆ‘ä»¬è¦ä¸€ä¸ªæœ€ä¼˜æƒ…å†µ,é‚£ä¹ˆæˆ‘ä»¬å°±è®¾ dp[i] [j]ä¸º å‰iä¸ªç‰©å“åˆ°jè¿™ä¸ªå€¼å–æˆ–è€…ä¸å–çš„æœ€ä¼˜æƒ…å†µ å› ä¸ºæ•°ç»„æœ‰è´Ÿæ•°æ‰€ä»¥æˆ‘ä»¬è¦ä¸€ä¸ªåç§»é‡,å› ä¸ºä¸‹æ ‡ä¸èƒ½ä¸ºè´Ÿ,æˆ‘ä»¬è§‚å¯Ÿåˆ°a[i]æœ€å¤š200,nåšå¤š200

æ‰€ä»¥æˆ‘ä»¬åœ¨åŒºé—´ -40000å’Œ40000 æ‰¾ä¸€ä¸ªåç§»é‡,å³40000 æˆ‘ä»¬æ•°ç»„å°±å˜æˆäº† dp[n +1] [80000];æˆ‘ä»¬ä¸‹æ ‡ä»1å¼€å§‹ è®¾dp[0] [40000] ä¸º0 å› ä¸ºæˆ‘ä»¬è¿™è¾¹çš„40000å·²ç»åšäº†åç§»,40000å°±æ˜¯åŸæ¥çš„0;ç„¶åæˆ‘ä»¬å–æˆ–ä¸å–

å–å°±æ˜¯xå˜æˆè´Ÿæ•°,å³j-x ,è¦åˆ¤æ–­ä¸€ä¸‹ä¸‹æ ‡è¶Šç•Œçš„æƒ…å†µ, ç„¶å dp[i] [j] = min(dp[i] [j],dp[i - 1] [j - x] + 1);

å¦‚æœä¸å–æˆ‘ä»¬å°±ä»ä¸Šä¸€ä¸ªçŠ¶æ€è½¬ç§» dp[i][j] = min(dp[i] [j], dp[i - 1] [j + x]) 

å’ŒèƒŒåŒ…ç±»ä¼¼,jæšä¸¾çš„æ˜¯èƒŒåŒ…å¤§å°

**ä»£ç :**

```c++
void solve(){
	int n;
	cin >> n;
	int dp[n+2][80008];
	memset(dp, 0x3f, sizeof dp);
	dp[0][40000] = 0;
	for(int i = 1; i <= n; i ++){
		int x;
		cin >> x;
		for(int j = 0; j <= 80000; j++){
			if(j + x <= 80000 && j + x >= 0) dp[i][j] = min(dp[i][j],dp[i - 1][j + x]);
			if(j - x <= 80000 && j - x >= 0) dp[i][j] = min(dp[i][j],dp[i - 1][j - x] + 1);
		}
	}
	if(dp[n][40000] >= 0x3f3f3f3f){
		cout << -1 << endl;
	}else{
		cout << dp[n][40000] <<endl; 
	}
}

```



#### 2.åŒºé—´dp

[#åŒºé—´ DP (qq.com)](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE3MTEyMA==&action=getalbum&album_id=2004942489941606403&scene=173&from_msgid=2247489400&from_itemidx=1&count=3&nolastread=1#wechat_redirect)

å®«æ°´ä¸‰å¶è®²è§£ åŒºé—´DP

![image-20231114151952628](img/image-20231114151952628.png)

![image-20240211152432304](img/image-20240211152432304.png)

#### 3.åºåˆ—ä¸ŠæŒ‰ç»“å°¾ä½ç½®è§„åˆ’

##### 1.æœ€é•¿é€’å¢å­åºåˆ—ç±»é—®é¢˜

##### 2.æœ€é•¿å…¬å…±å­åºåˆ—é—®é¢˜

dp[i] [j] ä»£è¡¨ s1 [0...i] s2[0...j];

è¿™ä¸ªåˆå§‹åŒ–å¾ˆå…³é”®,å¾—åˆå§‹åŒ–åŒ–ä¸¤è¾¹éƒ½ä¸º0çš„æƒ…å†µ å’Œä¸€è¾¹ä¸º0çš„æƒ…å†µ

```c++
dp[0][0] = 0;
for(int i = 1; i<= n;i++) dp[i][0] = s1[i - 1] + dp[i - 1][0];
for(int j = 1; j <= m;j++) dp[0][j] = s2[j - 1] + dp[0][j - 1];
```

#### å•è°ƒé˜Ÿåˆ—ä¼˜åŒ–DP

![image-20240214193218880](img/image-20240214193218880.png)

##### **ä¾‹é¢˜:**

###### **LOJ10180**

çƒ½ç«ä¼ é€’

[#10180. ã€Œä¸€æœ¬é€š 5.5 ç»ƒä¹  1ã€çƒ½ç«ä¼ é€’ - é¢˜ç›® - LibreOJ (loj.ac)](https://loj.ac/p/10180)

ä»£ç :

```c++
void solve(){
	int n,m;
	cin >> n >> m;
	int a[n + 1];
	for(int i = 1; i <= n; i++) cin >> a[i];
	int dp[n + 1];
	memset(dp,0,sizeof dp);
	deque<int> dq;
	int ans = 0x3f3f3f3f;
	for(int i = 1; i <= n;i++){
		while(!dq.empty() && dp[i - 1] <= dp[dq.back()]) dq.pop_back();
		dq.push_back(i - 1);
		while(dq.front() < i - m) dq.pop_front();
		dp[i] = dp[dq.front()] + a[i];
		if(i > n-m) ans = min(ans,dp[i]); 
	}
	cout << ans << endl;
}
```

###### LOJ10177

[#10177. ã€Œä¸€æœ¬é€š 5.5 ä¾‹ 3ã€ä¿®å‰ªè‰åª - é¢˜ç›® - LibreOJ (loj.ac)](https://loj.ac/p/10177)

**ä»£ç :**

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
typedef unsigned long long ULL;
typedef long long ll;
const int N = 100005;
void solve(){
	int n,k;
	cin >> n >> k;
	k++;
	deque<int> dq;
	int a[n + 1];
	int dp[n + 1];
	memset(dp,0,sizeof dp);
	int sum = 0;
	int ans = 1e18;
	for(int i = 1; i <= n; i++)  cin >> a[i], sum += a[i];
	for(int i = 1; i <= n; i++){
		while(!dq.empty() && dp[dq.back()] >= dp[i - 1]) dq.pop_back();
		dq.push_back(i - 1);
		while(dq.front() < i - k) dq.pop_front();
		dp[i] = dp[dq.front()] + a[i]; 	
		if(i+k > n){
			ans = min(ans,dp[i]);
		}
	}

	cout << sum - ans << endl;

}

signed main(){
	std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    std::cout.tie(0);
	int times = 1;
	//cin >> times;
	while(times--){
		solve();
	}
	return 0;
}
```

###### LOJ10181

[#10181. ã€Œä¸€æœ¬é€š 5.5 ç»ƒä¹  2ã€ç»¿è‰²é€šé“ - é¢˜ç›® - LibreOJ (loj.ac)](https://loj.ac/p/10181)

äºŒåˆ†+å•è°ƒé˜Ÿåˆ—dp

**ä»£ç :**

```c++
const int N = 100005;
int a[N];
int n,t;
bool check(int k){
	deque<int> dq;
	int dp[n + 1];
	memset(dp,0,sizeof dp);
	for(int i = 1; i <= n;i++){
		while(!dq.empty() && dp[i - 1] <= dp[dq.back()]){
			dq.pop_back();
		}
		dq.push_back(i-1);
		while(dq.front() < i - k) dq.pop_front();
		dp[i] = dp[dq.front()] + a[i];
		//cout << dp[i] << " ";
		if(i + k > n){
			if(dp[i] <= t) return true;
		}
	}
	//cout << endl;
	return false;

}
void solve(){
	cin >> n >> t;
	for(int i = 1; i <= n; i++) cin >> a[i];
	int l = 1, r = n;
	int ans = 0;
	while(l<=r){
		int mid = l+r>>1;
		//cout << mid << endl;
		if(check(mid)){
			ans = mid;
			r = mid - 1;
		}else{
			l = mid + 1;
		}
	}
	cout << ans - 1<< endl;
}

```

###### Luogu P1725

[P4742 [Wind Festival\] Running In The Sky - æ´›è°· | è®¡ç®—æœºç§‘å­¦æ•™è‚²æ–°ç”Ÿæ€ (luogu.com.cn)](https://www.luogu.com.cn/problem/P4742)

**ä»£ç :**

```c++
const int N = 200005;
void solve(){
	int n,l,r;
	cin >> n >> l >> r;
	int a[N];
	for(int i = 0; i <= n; i++){
		cin >> a[i];
	}
	deque<int> dq;
	int dp[N];
	memset(dp,-0x3f,sizeof dp);
	dp[0] = 0;
	int ans = -2e9;
	for(int i = l; i <= n; i++){
		while(!dq.empty() && dp[i - l] >= dp[dq.back()]) dq.pop_back();
		dq.push_back(i - l);
		if(dq.front() < i - r) dq.pop_front();
		if(dq.size() == 0){
			dp[i] = -0x3f;
		}else{
			dp[i] = a[i] + dp[dq.front()];
		}
		
		if(i > n - r){
			ans = max(dp[i],ans);
		}
	}
	cout << ans << endl;
}

```

### 4.äºŒç»´å·®åˆ† + äºŒç»´å‰ç¼€å’Œ

#### 1.äºŒç»´å‰ç¼€å’Œ

**ä»£ç :**

```c++
int n,m,q;
int grid[N][N];
int pre[N][N];
void solve(){
	cin >> n >> m >> q;
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= m;j++){
			cin >> grid[i][j];
		}
	}
	for(int i = 1;i <= n;i++){
		for(int j = 1; j <= m; j++){
			pre[i][j] = grid[i][j] + pre[i - 1][j] + pre[i][j - 1] - pre[i-1][j-1]; 
		}
	}
	while(q--){
		int x1,y1,x2,y2;
		cin >> x1 >> y1 >> x2 >> y2;
		int t = pre[x2][y2] - pre[x1 - 1][y2] - pre[x2][y1 - 1] + pre[x1 - 1][y1 - 1];
		cout << t << endl;
	}
}

```

#### 2.äºŒç»´å·®åˆ†

**ä»£ç :**

```c++
int n,m,q;
int grid[N][N];
int pre[N][N];
int d[N][N];
void solve(){
	cin >> n >> m >> q;
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= m;j++){
			cin >> grid[i][j];
		}
	}
	//å…ˆå·®åˆ†
	for(int i =1;i<=n;++i){
		for(int j = 1; j<=m;++j){
			d[i][j] += grid[i][j];
			d[i + 1][j] -= grid[i][j];
			d[i][j+1]-= grid[i][j];
			d[i+1][j+1] += grid[i][j]; 
		}
	}
	//è¿›è¡Œä¿®æ”¹
	while(q--){
		int x1,y1,x2,y2,v;
		cin >> x1 >> y1 >> x2 >> y2 >> v;
		d[x1][y1] += v;
		d[x1][y2+1]-=v;
		d[x2+1][y1]-=v;
		d[x2+1][y2+1]+=v;
	}
	//è¿˜åŸ
	for(int i = 1;i <= n;i++){
		for(int j = 1; j <= m; j++){
			grid[i][j] = grid[i - 1][j] + grid[i][j - 1] - grid[i - 1][j - 1] + d[i][j]; 
			cout << grid[i][j] << " ";
		}
		cout << endl;
	}
}
```

### 5.æ ‘é“¾å‰–åˆ†

![image-20240326142849200](img/image-20240326142849200.png)

#### ä¾‹é¢˜

##### è“æ¡¥æ¯14thçœèµ› 

[9.æ™¯åŒºå¯¼æ¸¸ - è“æ¡¥äº‘è¯¾ (lanqiao.cn)](https://www.lanqiao.cn/problems/3516/learning/?subject_code=1&group_code=4&match_num=14&match_flow=1&origin=cup)

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5+7;
int n,k;
vector<vector<pair<int,int>>> e(N);
int fa[N],top[N],son[N],dep[N],sz[N];
int dist[N];
int path[N];
void dfs1(int x,int fa1){
  sz[x] = 1;fa[x] = fa1;dep[x] = dep[fa1]+1;
  for(auto p:e[x]){
    int w = p.second;
    int v = p.first;
    if(v==fa[x]) continue;
    dist[v] = dist[x] + w;
    dfs1(v,x);
    sz[x]+=sz[v];
    if(sz[son[x]] < sz[v]) son[x] = v;
  }
}
void dfs2(int u,int t){
  top[u] = t;
  if(!son[u]) return;
  dfs2(son[u],t);
  for(auto p:e[u]){
    int v = p.first;
    if(v==son[u]||v==fa[u]) continue;
    dfs2(v,v);
  }
}
int lca(int n1,int n2){
  while(top[n1]!=top[n2]){
    if(dep[top[n1]] < dep[top[n2]]) swap(n1,n2);
    n1 = fa[top[n1]];
  }
  return dep[n1] < dep[n2] ? n1 :n2;
}
int js(int n1,int n2){
	if(n1==0||n2==0) return 0;
  return dist[n1]+dist[n2]-2*dist[lca(n1,n2)];
}
void solve(){
  cin >> n >> k;
  for(int i = 0; i < n - 1; i++){
    int u,v,w;
    cin >> u >> v >> w;
    e[u].push_back({v,w});
    e[v].push_back({u,w});
  } 
  dfs1(1,0);
  //cout << 1 <<endl;
  dfs2(1,1);
  int sum = 0;
  
  for(int i = 1; i <= k;i++){
    cin >> path[i];
    sum+=js(path[i],path[i-1]);
  }
  cout << sum << endl;
  for(int i = 1;i<=k;i++){
  	int g = sum - js(path[i],path[i-1]) - js(path[i],path[i+1]) + js(path[i - 1],path[i+1]);
  	cout << g << " ";
  }
}
int main(){
  solve();
}
```

### 6.æ ‘ä¸Šå·®åˆ†

#### æ¦‚å¿µä¸å…¬å¼:

**è¾¹å·®åˆ†:** w[a]++,w[b]++,w[lca(a,b)]-=2; å°†è¾¹ä¸‹æ”¾åˆ°ç‚¹ä¸Š

**ç‚¹å·®åˆ†:**w[a]++,w[b]++,w[lca(a,b)]--,w[fa[lca(a,b)]]--

![image-20240401135820865](img/image-20240401135820865.png)

#### å·®åˆ†è¿˜åŸ

```c++
void calcsum(int u,int fa){
  for(auto v:e[u]){
    if(v==fa) continue;
    calcsum(v,u);
    w[u]+=w[v];
  }
}
```

#### ä¾‹é¢˜:

##### **1.è“æ¡¥æ¯14thçœèµ›å‹è½´**

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5+7;
#define pb push_back

vector<vector<int> > e(N);
long long n,m;
int sz[N],son[N],top[N],fa[N],dep[N];
void dfs1(int u,int fa1){
  fa[u] = fa1,sz[u] = 1,dep[u] = dep[fa1] + 1;
  for(auto v:e[u]){
    if(v==fa1) continue;
    dfs1(v,u);
    sz[u] += sz[v];
    if(sz[son[u]] < sz[v]) son[u] = v;
  }
}
void dfs2(int u,int t){
  top[u] = t;
  if(!son[u]) return;
  dfs2(son[u],t);
  for(auto v:e[u]){
    if(v==fa[u] || v == son[u]) continue;
    dfs2(v,v);
  }
}
int lca(int a,int b){
  while(top[a]!=top[b]){
    if(dep[top[a]] < dep[top[b]]) swap(a,b);
    a = fa[top[a]];
  }
  return dep[a] < dep[b] ? a : b;
}
long long w[N];
map<pair<int,int>,int> h;
void calcsum(int u,int fa){
  for(auto v:e[u]){
    if(v==fa) continue;
    calcsum(v,u);
    w[u]+=w[v];
  }
}

void solve(){
  cin >> n >> m;
  for(int i = 0; i < n - 1; i++){
    int u,v;
    cin >> u >> v;
    e[u].pb(v);
    e[v].pb(u);
    h[{u,v}] = i + 1;
    h[{v,u}] = i + 1;
  }
  dfs1(1,0);
  dfs2(1,1);
  for(int i = 0; i < m;i++){
    int a,b;
    cin >> a >> b;
    w[a]++;
    w[b]++;
    w[lca(a,b)]-=2;
  }
  int ans = -1;
  calcsum(1,0);
  for(int i = 1; i <= n;i++){
    if(w[i]==m){
      ans = max(ans,h[{i,fa[i]}]);
    }
  }
  cout <<ans <<endl;
}
int main(){
  ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
  solve();
}
```

### 7.äºŒå‰æ ‘æ„é€ 

#### 1.ååºä¸ä¸­åº

```c++
tree* dfs(int is,int ie,int ps,int pe){
    if(is > ie || ps > pe) return NULL;
    int root = pre[pe];
    int ri = h[root];
    tree* node = new tree;
    node->v = root;
    int len = ri - is;
    tree* left =  dfs(is,ri - 1,ps,ps+len-1);
    tree* right = dfs(ri+1,ie,ps+len,pe-1);
    node->l = left;
    node -> r = right;
    return node;
}
```

#### 2.å‰åºä¸ä¸­åº

```c++
tree* dfs(int is,int ie,int ps,int pe){
    if(is > ie || ps > pe) return NULL;
    int root = pre[ps];
    int ri = h[root];
    tree* node = new tree;
    node->v = root;
    int len = ri - is;
    tree* left =  dfs(is,ri - 1,ps + 1,ps+len);
    tree* right = dfs(ri+1,ie,ps+len + 1,pe);
    node->l = left;
    node -> r = right;
    return node;
}
```

### 8.logtrick

å¯ä»¥åº”å¯¹ lcm gcd & | å­æ•°ç»„æ±‚å€¼é—®é¢˜

ä¸‰éƒ¨æ›²

1.å®šä¹‰orsæ•°ç»„ é€šå¸¸ç¬¬ä¸€ç»´åº¦ä¸º å€¼ ç”¨äºåšlogtrickä¼˜åŒ– ç¬¬äºŒä½ä¸ºå„ç§é¢˜ç›®é™åˆ¶/æˆ–è€…è¦æ±‚

2.è€ƒè™‘å¦‚ä½•åšlogtrick é€šå¸¸|ä¸&æ˜¯ç­‰äºæœ¬èº«å¯ä»¥åšlogtrick

3.è€ƒè™‘å¦‚ä½•æ±‚é—®é¢˜æ‰€éœ€å€¼

ä¸€èˆ¬æ¥è¯´å¸¦ä¸ª ä½ç½®ä¸‹æ ‡å€¼,ç»´æŠ¤è·ç¦»å¾ˆæœ‰ç”¨

**é…åˆmapä½¿ç”¨å°†ç®€åŒ–å¾ˆå¤šé—®é¢˜**

##### æ¨¡ç‰ˆ

```c++
vector<int/PII/vector<int>> orz;
//æˆ‘è¿™é‡Œé»˜è®¤æ•°ç»„ä¸‹æ ‡ä»1å¼€å§‹
for(int i = n;i>=1;i--){
	orz.push_back({0,ä¸€äº›æ•°});
    orz[0] | / & / gcd / lcm = nums[i];
    int k = 0;
    for(int j = 1;j<orz.size();j++){
        orz[j] | / & / gcd / lcm = nums[i];
        if(orz[j] == orz[k]){
            //æ“ä½œ
        }else{
            orz[++k] = orz[j]
        }
    }
    resize(orz,k+1);
    //æœ€åå¯åšç»Ÿè®¡æ±‚å€¼å·¥ä½œ
}

```

##### logtrické­”æ”¹ç‰ˆ

é­”æ”¹æ˜¯åŸåœ°ä¿®æ”¹ç®—æ³•,ä¼šæœ‰å•è°ƒæ€§,å¯ä»¥äºŒåˆ†æŸ¥å€¼

é­”æ”¹èƒ½è§£å†³å¾ˆå¤šé—®é¢˜,ä½†æ˜¯ä¸€äº›è®¡æ•°ä¸å»é‡éœ€è¦åŸç‰ˆå®Œæˆ

```c++
for(int i = 1; i <= n;i++){
    int x = nums[i];
    //è¿™é‡Œå¯ä»¥è¿›è¡Œä¸€äº›æ“ä½œæ¯”å¦‚è¯´å¯¹å•ä¸ªå€¼å–å€¼ è¿˜æœ‰
    for(int j = i - 1;j >= 1 && ((nums[j] æ“ä½œ nums[i]) != nums[j]);j--){
        nums[j] æ“ä½œ= nums[i];
    }
    ç„¶åè¿›è¡ŒäºŒåˆ†æˆ–è€…ä¸€äº›æ“ä½œ
}
```

ä¾‹é¢˜:

åŠ›æ‰£

3097.æˆ–å€¼è‡³å°‘ä¸º K çš„æœ€çŸ­å­æ•°ç»„ II 1891 
2411.æŒ‰ä½æˆ–æœ€å¤§çš„æœ€å°å­æ•°ç»„é•¿åº¦ 1938
3209.å­æ•°ç»„æŒ‰ä½ä¸å€¼ä¸º K çš„æ•°ç›® 2100
3171.æ‰¾åˆ°æŒ‰ä½æˆ–æœ€æ¥è¿‘ K çš„å­æ•°ç»„
1521.æ‰¾åˆ°æœ€æ¥è¿‘ç›®æ ‡å€¼çš„å‡½æ•°å€¼ 2384 åšæ³•åŒ 3171 é¢˜ 
898.å­æ•°ç»„æŒ‰ä½æˆ–æ“ä½œ 

### 9.æ ‘ä¸Šå¯å‘å¼åˆå¹¶

[dsu on tree(æ ‘ä¸Šå¯å‘å¼åˆå¹¶) - GsjzTle - åšå®¢å›­ (cnblogs.com)](https://www.cnblogs.com/GsjzTle/p/14033777.html)

**ä¾‹é¢˜:**

##### CF570D

```c++
const int N = 500005;
struct edges{
    int v,ne;
}e[N<<1];
struct quary{
    int h,id;
};
vector<quary> tb[N];
int h[N],idx = 0;
void add(int u,int v){
    e[idx] = {v,h[u]};
    h[u] = idx++;
}
string s;
int n,q;
int cnt[N][26];
int sz[N],dep[N],son[N];
int flag;
int ans[N];
void dfs(int u,int f,int path){
    sz[u] = 1,dep[u] = path;
    for(int i = h[u];~i;i=e[i].ne){
        int v= e[i].v;
        if(v==f) continue;
        dfs(v,u,path+1);
        sz[u]+=sz[v];
        if(sz[son[u]] < sz[v]){
            son[u] = v;
        }
    }
}
void count(int u,int f,int val){
    cnt[dep[u]][s[u] - 'a']+=val;
    for(int i = h[u];~i;i=e[i].ne){
        int v = e[i].v;
        if(v==flag || v == f) continue;
        count(v,u,val);
    }
}
void dfs2(int u,int f,int keep){
    //éå†è½»å„¿å­,ç®—å­æ•°,åˆ è´¡çŒ®
    for(int i = h[u];~i;i=e[i].ne){
        int v = e[i].v;
        if(v == f || v == son[u]) continue;
        dfs2(v,u,0);
    }
    if(son[u]){
        dfs2(son[u],u,1);
         flag = son[u];
    }
    count(u,f,1);
    flag = 0;
    for(auto &p:tb[u]){
        int h = p.h;
        int id = p.id;
        int ct = 0;
        for(int i = 0; i < 26;i++){
            if(cnt[h][i]%2==1) ct++;
        }
        if(ct<=1) ans[id] = 1;
    }
    if(!keep){
        count(u,f,-1);
    }
}
void solve(){
    memset(h,-1,sizeof h);
    cin >> n >> q;
    for(int i = 2;i <= n;i++){
        int u;
        cin >> u;
        add(u,i);
        add(i,u);
    }
    cin >> s;
    s=" " + s;
    int id = 0;
    int g = q;
    while(q--){
        int x,y;
        cin >> x >> y;
        tb[x].push_back({y,id++});
    }
    dfs(1,0,1);
    dfs2(1,0,0);
    for(int i = 0;i<g;i++){
        if(!ans[i]){
            cout << "No" << endl;
        }else{
            cout << "Yes" << endl;
        }
    }
}
```

##### CF600E

```c++
const int N = 200005;
struct edges{
    int v,ne;
}e[N<<1];
int h[N],idx = 0;
void add(int u,int v){
    e[idx] = {v,h[u]};
    h[u] = idx++;
}
int n;
int color[N],cnt[N],ans[N];
int fa[N],sz[N],son[N]; //å¯»æ‰¾é‡å„¿å­
int flag;
void dfs(int u,int f){
    sz[u] = 1,fa[u] = f;
    int masz = -1;
    for(int i = h[u];~i;i=e[i].ne){
        int v = e[i].v;
        if(v==f) continue;
        dfs(v,u);
        if(masz < sz[v]){
            masz = sz[v];
            son[u] = v;
        }
        sz[u] += sz[v];
    } 
}
int sum = 0,ma = 0;
void count(int u,int f,int val){
    cnt[color[u]]+=val;
    if(cnt[color[u]] > ma){
        ma = cnt[color[u]];
        sum = color[u];
    }else if(cnt[color[u]] ==ma){
        sum += color[u];
    }
    for(int i = h[u];~i;i=e[i].ne){
        int v = e[i].v;
        if(v==f || v == flag) continue;
        count(v,u,val);
    }
}
void dfs(int u,int f,int keep){
    //ç®—è½»å„¿å­,ç®—ç­”æ¡ˆ,åˆ è´¡çŒ®
    for(int i = h[u];~i;i=e[i].ne){
        int v = e[i].v;
        if(v==f || v == son[u]) continue;
        dfs(v,u,false);
    }
    //ç®—é‡å„¿å­è´¡çŒ®,ä¸åˆ 

    if(son[u]){
        dfs(son[u],u,true);
        flag = son[u];
    }
    //åˆå¹¶ä¿¡æ¯
    count(u,f,1);
    flag = 0; //åˆ è´¡çŒ®æ—¶ä¸‹é¢çš„é‡å„¿å­ä¹Ÿæ˜¯åˆ çš„(å› ä¸ºæˆ‘æœ¬èº«æ˜¯è½»å„¿å­)
    ans[u] = sum;
    //åˆ è´¡çŒ®,è¿›å…¥ä¸‹ä¸€è½®å­æ ‘
    if(!keep){
        count(u,f,-1);
        sum = 0,ma = 0;
    }
}
void solve(){
    //å…ˆå»ºæ ‘
    cin >> n;
    memset(h,-1,sizeof h);
    for(int i = 1;i <= n;i++){
        cin >> color[i];
    }
    for(int i = 1;i < n; i++){
        int u,v;
        cin >> u >> v;
        add(u,v);
        add(v,u);
    }
    dfs(1,0);
    dfs(1,0,0);
    for(int i = 1;i<=n;i++){
        cout << ans[i] <<" ";
    }
}
```

##### CF208E

```c++
const int P = 13331;
const int N = 200005;
//å»ºå›¾
struct egdes
{
    int v,ne;
}e[N<<1];
int h[N],idx = 0;
 
void add(int u,int v){
    e[idx] = {v,h[u]};
    h[u] = idx++;
}
int pa[N][36];//å¤„ç†kçº§å…¬å…±ç¥–å…ˆ
int n;
int fa[N];
void init(){
    for(int i = 0; i < 30;i++){
        for(int x = 1; x <= n;x++){
            int p = pa[x][i];
            if(p>0){
                pa[x][i+1] = pa[p][i];
            }
        }
    }
}
int gtk(int v,int k){
    for(int i = 0; i < 30;i++){
        if(k & (1<<i)){
            v = pa[v][i];
            if(v<=0) continue;
        }
    }
    return v;
}
struct quary{
    int k,id,node;
};
vector<quary> qs[N];//æ¯ä¸ªèŠ‚ç‚¹è¦ç®—çš„ä¸œè¥¿
int sz[N],son[N],dep[N];
int mah = 0;
void dfs(int u,int f,int hi){
    sz[u] = 1,dep[u] = hi;
    mah=max(hi,mah);
    for(int i = h[u];~i;i=e[i].ne){
        int v = e[i].v;
        if(v==f) continue;
        dfs(v,u,hi+1);
        sz[u]+=sz[v];
        if(sz[son[u]] < sz[v]){
            son[u] = v;
        }
    }
}
int cnt[N],flag;
int ans[N];
void count(int u,int f,int val){
    
    cnt[dep[u]]+=val;
    //printf("%d %d %d\n",u,dep[u],cnt[dep[u]]);
    for(int i = h[u];~i;i=e[i].ne){
        int v = e[i].v;
        if(v==f||v == flag) continue;
        count(v,u,val);
    }
}
void dfs2(int u,int f,int keep){
    for(int i = h[u];~i;i=e[i].ne){
        int v = e[i].v;
        if(v==f||v==son[u]) continue;
        dfs2(v,u,0);
    }
    if(son[u]){
        dfs2(son[u],u,1);
        flag = son[u];//falgåˆ‡è®°åœ¨ä¸‹é¢
    }
    
    count(u,f,1);
    flag = 0;
    for(auto &p:qs[u]){
        int id = p.id,k = p.k,node = p.node;
        //printf("%d %d %d %d %d\n",u,node,dep[u],dep[node],cnt[dep[node]]);
        if(cnt[dep[node]]==0) continue;
        ans[id] = cnt[dep[node]] - 1;
    }
 
    if(!keep) count(u,f,-1);
    
 
}
void solve(){
    cin >> n;
    memset(h,-1,sizeof h);
    vector<int> roots;
    for(int i = 1;i<=n;i++) {
        cin>>fa[i];
        
        if(fa[i]==0){
            roots.push_back(i);
            continue;
        }
        pa[i][0] = fa[i];
        add(i,fa[i]);
        add(fa[i],i);
    }
    init();
    int q;
    for(auto &p:roots) dfs(p,0,1);
    cin >> q;
    int id = 0;
    int qq = q;
    while(q--){
        int node,k;
        cin >> node >> k;
        int nr = gtk(node,k);
        if(nr!=0){
            qs[nr].push_back({k,id,node});
        }
        id++;
    }
    for(auto &p:roots){
        dfs2(p,0,0);
    }
    for(int i = 0;i <qq;i++){
        cout << ans[i] << endl;
    }
}
```

##### CF246E

```c++
const int N = 200005;
int n;
struct edges{
    int v,ne;
}e[N];
struct quarys{
    int k,id;
};
vector<quarys> qs[N];
int h[N],idx = 0;
void add(int u,int v){
    e[idx] = {v,h[u]};h[u] = idx++;
}
string name[N];
int dep[N],sz[N],son[N];
void dfs(int u,int f){
    sz[u] = 1,dep[u] = dep[f] + 1;
    for(int i = h[u];~i;i=e[i].ne){
        int v = e[i].v;
        if(v==f) continue;
        dfs(v,u);
        sz[u]+=sz[v];
        if(sz[son[u]] < sz[v]){
            son[u] = v;
        }
    }
}
int flag;

int cnt[N];
int ans[N];
map<pair<int,string>,int> se;
void count(int u,int f,int val){
    if(val!=-1 && !se.count({dep[u],name[u]})){
        cnt[dep[u]]+=val;
    }
    se[{dep[u],name[u]}]+=val;
    if(se[{dep[u],name[u]}]==0){
        se.erase({dep[u],name[u]});
        cnt[dep[u]]--;
    }
    for(int i = h[u];~i;i=e[i].ne){
        int v = e[i].v;
        if(v==f||v==flag) continue;
        count(v,u,val);
    }
}
void dfs2(int u,int f,int keep){
    for(int i = h[u];~i;i=e[i].ne){
        int v = e[i].v;
        if(v==f || v==son[u]) continue;
        dfs2(v,u,0);
    }
    if(son[u]){
        dfs2(son[u],u,1);
        flag = son[u];
    }
    count(u,f,1);
    //se.clear();    
    flag = 0;
    for(auto &p:qs[u]){
        int k = p.k;
        int id = p.id;
        ans[id] = cnt[dep[u] + k];
    }
    if(!keep){
        count(u,f,-1);
    }
}
void solve(){
    cin >> n;
    memset(h,-1,sizeof h);
    vector<int> roots;
    for(int i = 1;i<=n;i++){
        cin >> name[i];
        int fa;
        cin >> fa;
        if(fa==0){
            roots.push_back(i);
            continue;
        }
        add(i,fa);
        add(fa,i);
    }
    int q;
    cin >> q;
    int id = 0;
    while(id<q){
        int node,k;
        cin >> node >> k;
        qs[node].push_back({k,id});
        id++;
    }
    for(auto &p:roots){
        dfs(p,0);
        dfs2(p,0,0);
    }
    for(int i = 0; i < q;i++){
        cout << ans[i] << endl;
    }
}
```

##### CF1009F

```c++
const int N = 1000005;
struct edges
{
    int v,ne;
}e[N << 2];
int n;
int h[N],idx = 0;
void add(int u,int v){
    e[idx] = {v,h[u]};
    h[u] = idx++;
}
int sz[N],dep[N],mdep,son[N];
void dfs(int u,int f){
    sz[u] = 1; dep[u] = dep[f] + 1;
    mdep = max(mdep,dep[u]);
    for(int i = h[u];~i;i=e[i].ne){
        int v=e[i].v;
        if(v==f) continue;
        dfs(v,u);
        sz[u]+=sz[v];
        if(sz[son[u]]<sz[v]) son[u] = v;
    }
}
int flag;
int cnt[N],ans[N];
int ma,id = 0;
void count(int u,int f,int val){
    cnt[dep[u]]+=val;
    if(cnt[dep[u]] > ma){
        ma = cnt[dep[u]];
        id = dep[u];
    }else if(cnt[dep[u]] == ma){
        id = min(id,dep[u]);
    }
    for(int i = h[u];~i;i=e[i].ne){
        int v = e[i].v;
        if(v==flag||v==f)continue;
        count(v,u,val);
    }
}
void dfs2(int u,int f,int keep){
    for(int i = h[u];~i;i=e[i].ne){
        int v = e[i].v;
        if(v==f||v==son[u]) continue;
        dfs2(v,u,0);
    }
    if(son[u]){
        dfs2(son[u],u,1);
        flag = son[u];
    }
    count(u,f,1);
    flag = 0;
   
    ans[u] = max(id - dep[u],0);
    if(!keep){
        count(u,f,-1);
        ma=0;
        id=0;
    }
}
void solve(){
    memset(h,-1,sizeof h);
    cin >> n;
    for(int i =0;i<n-1;i++){
        int u,v;
        cin >> u >> v;
        add(u,v);
        add(v,u);
    }
    dfs(1,0);
    dfs2(1,0,0);
    for(int i = 1;i<=n;i++) cout << ans[i] << endl;
}
```

##### CF375D

```c++
const int N = 100005;
int n,m;
int color[N];
struct edges{
    int v,ne;
}e[N << 2];
int h[N],idx = 0;
struct quars{
    int k,id;
};
int tr[N];
int lb(int x){return x&-x;}
void upd(int k,int val){
    for(int i = k;i < N;i+=lb(i)) tr[i]+=val;
}
int quary(int k){
    int res = 0;
    for(int i = k - 1;i>0;i-=lb(i)){
        res+=tr[i];
    }
    return res;
}
void add(int u,int v){
    e[idx] = {v,h[u]};
    h[u] = idx++;
}
vector<quars> qs[N];
int ans[N];
int sz[N],son[N];
void dfs(int u,int f){
    sz[u] = 1;
    for(int i = h[u];~i;i=e[i].ne){
        int v = e[i].v;
        if(v==f) continue;
        dfs(v,u);
        sz[u]+=sz[v];
        if(sz[son[u]] < sz[v]) son[u] = v;
    }
}
int flag;
int col[N];
int p1 = 0;
void count(int u,int f,int val){
    if(col[color[u]]!=0){
        upd(col[color[u]],-1);
    }else{
        p1++;
    }
    col[color[u]]+=val;
    if(col[color[u]]!=0){
        upd(col[color[u]],1);
    }else{
        p1--;
    }
    for(int i = h[u];~i;i=e[i].ne){
        int v = e[i].v;
        if(v==f||v==flag) continue;
        count(v,u,val);
    }
}
void dfs2(int u,int f,int keep){
    for(int i = h[u];~i;i=e[i].ne){
        int v = e[i].v;
        if(v==f||v==son[u]) continue;
        dfs2(v,u,0);
    }
    if(son[u]){
        dfs2(son[u],u,1);
        flag = son[u];
    }
    count(u,f,1);

    for(auto &p:qs[u]){
        int k = p.k, id = p.id;
        //cout << col[color[2]] << " " << quary(k)<< endl;
        ans[id] = p1 - quary(k);
    }
    flag = 0;
    if(!keep){
        count(u,f,-1);
    }

}
void solve(){
    cin >> n >> m;
    memset(h,-1,sizeof h);
    for(int i = 1;i<=n;i++) cin >> color[i];
    for(int i = 0; i < n - 1;i++){
        int u,v;
        cin >> u >> v;
        add(u,v);
        add(v,u);
    }
    int id = 1;
    while(id <= m){
        int u,k;
        cin >> u >> k;
        qs[u].push_back({k,id});
        id++;
    }
    dfs(1,0);
    dfs2(1,0,0);
    for(int i = 1;i < id;i++){
        cout << ans[i] << endl;
    }

}

```

##### wannafly Day2 E

[E-é˜”åŠ›æ¢¯çš„æ ‘_2020 CCPC Wannafly Winter Camp Day2 Div.1&2ï¼ˆé‡ç°èµ›ï¼‰ (nowcoder.com)](https://ac.nowcoder.com/acm/contest/4010/E)

```c++
const int N = 200005;
struct edges{
    int v,ne;
}e[N<<1];
int h[N],idx = 0;
void add(int u,int v){
    e[idx] = {v,h[u]};
    h[u] = idx++;
}

int sz[N],son[N];

void dfs(int u,int f){
    sz[u] = 1;
    for(int i = h[u];~i;i=e[i].ne){
        int v= e[i].v;
        if(v==f) continue;
        dfs(v,u);
        sz[u]+=sz[v];
        if(sz[son[u]] < sz[v]){
            son[u] = v;
        }
    }
}
int flag;
int ans[N];
int su;
set<int> se;
void upd(int u,int f){
    auto it1 = se.upper_bound(u);
    auto it2 = it1,it = it1;
    it2--;
    int de = 0,ad1 = 0,ad2 = 0;
    if(it2 != se.begin() && it != se.end()) de=(*it- *it2);
    su-=de*de;
    if(it2 != se.begin()) ad1 = (u - *it2);
    if(it != se.end()) ad2 = (*it - u);
    su+=ad1*ad1+ad2*ad2;
    se.insert(u);
    for(int i = h[u];~i;i=e[i].ne){
        int v = e[i].v;
        if(v == f || v == flag) continue;
        upd(v,u);
    }
}
void del(int u,int f){
    se.erase(u);
    auto it1 = se.upper_bound(u);
    auto it2 = it1,it = it1;
    it2--;
    int de = 0,ad1 = 0,ad2 = 0;
    if(it2 != se.begin()) ad1 = (u- *it2);
    if(it != se.end()) ad2 = (*it - u);
    su-=ad1*ad1;
    su-=ad2*ad2;
    if(it2 != se.begin() && it != se.end()) de=(*it- *it2);
    su+=de*de;
    for(int i = h[u];~i;i=e[i].ne){
        int v = e[i].v;
        if(v == f || v == flag) continue;
        del(v,u);
    }
}
void dfs2(int u,int f,int keep){
    for(int i = h[u];~i;i=e[i].ne){
        int v = e[i].v;
        if(v == f || v == son[u]) continue;
        dfs2(v,u,0);
    }
    if(son[u]){
        dfs2(son[u],u,1);
        flag = son[u];
    }
    upd(u,f);
    flag = 0;
    ans[u] = su;
    if(!keep){
        del(u,f);
        su = 0;
    }

}
int n;
void solve(){
    memset(h,-1,sizeof h);
    cin >> n;
    se.insert(-100);
    for(int i = 2;i<=n;i++){
        int fa;
        cin >> fa;
        add(fa,i);
        add(i,fa);
    }
    dfs(1,0);
    dfs2(1,0,0);
    for(int i = 1;i<=n;i++) cout << ans[i] << endl;
}

```



##### CCPCé•¿æ˜¥2022F

[Problem - F - Codeforces](https://codeforces.com/gym/102832/problem/F)

```c++
const int N = 100005;
int n;
int a[N];
struct edges
{
    int v,ne;
}e[N << 2];
int h[N],idx;
void add(int u,int v){
    e[idx] = {v,h[u]};
    h[u] = idx++;
}
int sz[N],son[N];
void dfs(int u,int f){
    sz[u] = 1;
    for(int i = h[u];~i;i=e[i].ne){
        int v = e[i].v;
        if(v==f) continue;
        dfs(v,u);
        sz[u]+=sz[v];
        if(sz[son[u]] < sz[v]){
            son[u] = v;
        }
    }
}
int cnt[1000006][20][2]; //å¼‚æˆ–å€¼ä¸ºxçš„ç¬¬iä½ä¸Š0/1çš„ä¸ªæ•°
int flag;
ll res = 0;
void change(int u,int f,int val){

    for(int i = 0; i <=17;i++){
        if(u&(1<<i)){
            cnt[a[u]][i][1]+=val;
        }else{
            cnt[a[u]][i][0]+=val;
        }
    }
    for(int i = h[u];~i;i=e[i].ne){
        int v = e[i].v;
        if(v==f||v==flag) continue;
        change(v,u,val);
    }

}
void count(int rt,int u,int f){
    if((a[u]^a[rt]) <= 1000000){
        for(int i = 0; i <= 17;i++){
            int p = (u >> i)&1;
            res += cnt[a[u]^a[rt]][i][p^1] * (1<<i);
        }
    }
    
    for(int i = h[u];~i;i=e[i].ne){
        int v = e[i].v;
        if(v==f||v==flag) continue;
        count(rt,v,u);
    }

}
void dfs2(int u,int f,int keep){
    for(int i = h[u];~i;i=e[i].ne){
        int v = e[i].v;
        if(v==f||v==son[u]) continue;
        dfs2(v,u,0);
    }
    if(son[u]){
        dfs2(son[u],u,1);
        flag = son[u];
    }
    for(int i = h[u];~i;i=e[i].ne){
        int v = e[i].v;
        if(v==f||v==flag) continue;
         count(u,v,u);
        change(v,u,1);
    }
    flag = 0;
    for(int i = 0; i <=17;i++){
        if(u&(1<<i)){
            cnt[a[u]][i][1]++;
        }else{
            cnt[a[u]][i][0]++;
        }
    }
    if(!keep){
        change(u,f,-1);
    }
}
void solve(){
    memset(h,-1,sizeof h);
    cin >> n;
    for(int i = 1;i<=n;i++) cin >> a[i];
    for(int j = 0;j<n - 1;j++){
        int u,v;
        cin >> u >> v;
        add(u,v);
        add(v,u);
    }
    dfs(1,0);
    dfs2(1,0,0);
    cout << res;

}
```

##### ç‰›å®¢ç»ƒä¹ èµ›60E

[E-æ——é¼“ç›¸å½“çš„å¯¹æ‰‹_ç‰›å®¢ç»ƒä¹ èµ›60 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/4853/E)

```c++
struct edges
{
    int v,ne;
}e[N << 1];
int h[N],idx;
void add(int u,int v){
    e[idx] = {v,h[u]};
    h[u] = idx++;
}
int rt[N],ans[N];
int n,k;
int dep[N],son[N],sz[N];
void dfs(int u,int f){
    sz[u] = 1,dep[u] = dep[f] + 1;
    for(int i = h[u];~i;i=e[i].ne){
        int v = e[i].v;
        if(v==f) continue;
        dfs(v,u);
        sz[u]+=sz[v];
        if(sz[son[u]] < sz[v]) son[u] = v;
    }
}
int flag;
int cnt[N];
int zsu[N];
int su = 0;
void count(int u,int f,int rt1){
    if(2*dep[rt1]+k-dep[u] > dep[rt1] && 2*dep[rt1]+k-dep[u] >= 1) su+=zsu[2*dep[rt1]+k-dep[u]]+ cnt[2*dep[rt1]+k-dep[u]]* rt[u];
    for(int i = h[u];~i;i=e[i].ne){
        int v = e[i].v;
        if(v==f||v==flag) continue;
        count(v,u,rt1);
    }
}
void upd(int u,int f,int val){
    cnt[dep[u]]+=val;
    if(val==-1){
        zsu[dep[u]]-=rt[u];
    }else{
        zsu[dep[u]]+=rt[u];
    }
    for(int i = h[u];~i;i=e[i].ne){
        int v = e[i].v;
        if(v==f||v==flag) continue;
        upd(v,u,val);
    }
}
void dfs2(int u,int f,int keep){
    for(int i = h[u];~i;i=e[i].ne){
        int v = e[i].v;
        if(v==f||v==son[u]) continue;
        dfs2(v,u,0);
    }
    if(son[u]){
        dfs2(son[u],u,1);
        flag = son[u];
    }
    for(int i = h[u];~i;i=e[i].ne){
        int v = e[i].v;
        if(v==f||v==flag) continue;
        count(v,u,u);upd(v,u,1);
    }
    flag = 0;
    ans[u] = su;
    su = 0;//æ¯ä¸ªå­æ•°ç‹¬ç«‹è®¡ç®—,å³ä½¿é‡å„¿å­ä¹Ÿè¦æ¸…é›¶
    cnt[dep[u]]+=1;
    zsu[dep[u]]+=rt[u];
    if(!keep){
        upd(u,f,-1);
    }
}
void solve(){
    memset(h,-1,sizeof h);
    cin >> n >> k;
    for(int i = 1;i<=n;i++) cin >> rt[i];
    for(int i = 0; i < n - 1;i++){
        int u,v;
        cin >> u >> v;
        add(u,v);
        add(v,u);
    }
    dfs(1,0);
    dfs2(1,0,0);
    for(int i = 1;i<=n;i++) cout << ans[i] << " ";
}
```



### 10.æ ‘ä¸Šå€å¢

https://blog.csdn.net/jj6666djdbbd/article/details/128980621

#### 1.kçº§ç¥–å…ˆ

```c++
//é¢„å¤„ç†

for (int i = 1; i < n; i++)
     pa[i][0] = parent[i];
for (int i = 0; i < 30; i++)
    for (int x = 0; x < n; x++)
        if (int p = pa[x][i]; p != -1)
            pa[x][i + 1] = pa[p][i];
   
```



## <a name = "swjqp">äºŒ æ€ç»´æŠ€å·§ç¯‡</a>

### 1.é€†åºå¯¹

é€†åºå¯¹æ˜¯è¿™æ ·å®šä¹‰çš„ï¼šå¯¹äºç»™å®šçš„ä¸€æ®µæ­£æ•´æ•°åºåˆ—ï¼Œé€†åºå¯¹å°±æ˜¯åºåˆ—ä¸­ai>ajä¸”i<jçš„æœ‰åºå¯¹ã€‚

å½’å¹¶æ’åºæ±‚é€†åºå¯¹ä»£ç :

```c++
int marge(int p[],int l,int r){
	if(l>=r) return 0;
	int mid = l+r>>1;
	int ans = marge(p,l,mid) + marge(p,mid+1,r);
	int i = l, j = mid + 1,k = 0;
	while(i <= mid && j <= r){
		if(p[i]<=p[j]){
			tmp[k++]=p[i++];
		}else{
			tmp[k++]=p[j++];
			ans+=mid-i+1;
		}
	}
	while(i<=mid){
		tmp[k++] = p[i++];
	}
	while(j<=r){
		tmp[k++]=p[j++];
	}
	for(int i = l,j=0;i<=r;i++,j++){
		p[i] = tmp[j];
	}
	return ans;
}
```



## <a name = "trp">ä¸‰ å›¾è®ºç¯‡</a>

### åŸºç¡€æ¨¡å—

#### (1)é“¾å¼å‰å‘æ˜Ÿ

é‚»æ¥è¡¨å£°æ˜

```c++
int h[N], e[M], w[M], ne[M], idx; //é‚»æ¥è¡¨ NèŠ‚ç‚¹ä¸ªæ•°ï¼ŒMè¾¹ä¸ªæ•°
 
//å…¶ä¸­ 
//h[a] æŒ‡å‘aèŠ‚ç‚¹èµ·ç‚¹çš„é‚»æ¥è¡¨åˆ—è¡¨çš„æœ€åä¸€ä¸ªå…ƒç´ ã€‚
//e[idx] ä¸ºå½“å‰idxç¼–å·çš„è¾¹æŒ‡å‘çš„ç»ˆç‚¹èŠ‚ç‚¹
//w[idx] ä¸ºå½“å‰idxç¼–å·çš„è¾¹æƒé‡
//ne å­˜å‚¨é‚»æ¥è¡¨é“¾è¡¨ï¼Œå½“å‰å€¼å¯¹åº”é‚»æ¥è¡¨ä¸­ä¸‹ä¸€ä¸ªçš„åœ°å€ï¼Œç±»ä¼¼äºå€¼æ˜¯æŒ‡é’ˆã€‚
 
//åˆå§‹åŒ–
idx = 0;
memset(h, -1, sizeof h);
 
```

é‚»æ¥è¡¨æ„å»º

```c++
void add(int a, int b, int c) { //æ„å»ºé‚»æ¥è¡¨
    e[idx] = b;
    w[idx] = c;
    ne[idx] = h[a]; 
    h[a] = idx++;  //h[a] ä¸€ç›´æŒ‡å‘aé‚»æ¥è¡¨å¤´æ’æ³•èµ·ç‚¹ï¼Œå…¶å®æ˜¯æœ€åä¸€ä¸ªï¼ŒæŒ‡é’ˆä¿ç•™çš„æ–¹å¼ä¹Ÿæ˜¯å‘å‰
}
//
//1. idxä¸€ç›´å‘å‰ï¼Œå¦‚æœaæ˜¯ç¬¬ä¸€æ¬¡å‡ºç°ï¼Œåˆ™h[a]çš„å€¼å¯¹åº”neä¸­ä½ç½®å³æ˜¯èµ·ç‚¹ã€‚
//2. æ’å…¥çš„æ–¹å¼æ˜¯ç±»ä¼¼å¤´æ’æ³•ï¼Œæ¯æ¬¡é‚»æ¥è¡¨ä¸­çš„æ–°å…ƒç´ å‡ºç°ï¼Œåˆ™æ’å…¥é‚»æ¥é“¾è¡¨çš„ç¬¬ä¸€ä¸ªã€‚ä¹Ÿå¯ä»¥è¿™æ ·ç†è§£ï¼Œæ˜¯æ¯æ¬¡æ’åˆ°æœ€åï¼Œè®©h[a]æŒ‡å‘æœ€åä¸€ä¸ªå…ƒç´ ï¼Œéå†çš„æ—¶å€™å€’ç€å‘å‰éå†ã€‚
//3. å¦‚æœæŒ‡å‘ä¸‹ä¸€ä¸ªä¸ºç©ºæ—¶ï¼ŒæŒ‡é’ˆå€¼ä¸º-1.
```

é‚»æ¥è¡¨éå†

```c++
for(int i = h[vel]; i != -1; i = ne[i]) { 
    //TODO
}
 
//i = ne[i] æ¨¡æ‹Ÿé“¾è¡¨æŒ‡é’ˆçš„nextæ“ä½œ
//h[vel] æŒ‡å‘velé“¾è¡¨çš„æœ€åä¸€ä¸ªï¼Œéå†æ˜¯ä»åå¾€å‰çš„
```

å‚è€ƒèµ„æ–™:

https://zhuanlan.zhihu.com/p/466362219

#### (2)ç¨€ç–å›¾ä¸ç¨ å¯†å›¾

**ç¨€ç–å›¾å’Œç¨ å¯†å›¾:**
**è¿™ä¸¤ç§å›¾æ˜¯ç›¸å¯¹å­˜åœ¨çš„ï¼Œå³å¦‚æœå›¾ä¸­å…·æœ‰å¾ˆå°‘çš„è¾¹ï¼ˆæˆ–å¼§ï¼‰ï¼Œæ­¤å›¾å°±ç§°ä¸º"ç¨€ç–å›¾"ï¼›åä¹‹ï¼Œåˆ™ç§°æ­¤å›¾ä¸º"ç¨ å¯†å›¾"ã€‚**

### 1.æœ€çŸ­è·¯å›¾è®º

![image-20240104210748099](img/image-20240104210748099-1704373686228-2.png)

#### (1)Dijkstra

**è¯¥ç®—æ³•å¯ä»¥ç®—å‡ºä»ä¸€ä¸ªé¡¶ç‚¹åˆ°å…¶ä½™å„é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ï¼Œè§£å†³çš„æ˜¯æ±‚æ— è´Ÿæƒè¾¹çš„å•æºæœ€çŸ­è·¯ã€‚**

**æ—¶é—´å¤æ‚åº¦ O(n^2)**;

```c++
const int N = 501;
int g[N][N];//é‚»æ¥çŸ©é˜µ
int dist[N]; //ä»èµ·ç‚¹åˆ°å„èŠ‚ç‚¹çš„æœ€çŸ­è·¯
bool st[N]; //æ˜¯å¦ç¡®å®šå·²ç»æ˜¯æœ€çŸ­è·¯;
int n,m; 
int start,end;

int dis() {
	memset(dist,0x3f,sizeof dist);
	dist[1] = 0; //åˆå§‹åŒ–èµ·ç‚¹åˆ°èµ·ç‚¹è·ç¦»ä¸º0; //1ä¸ºèµ·ç‚¹ 
	for(int i = 0; i < n;i++){ //forå¾ªç¯,ä¿è¯æ¯æ¬¡è¿­ä»£éƒ½èƒ½ç¡®å®šä¸€ä¸ªç‚¹çš„æœ€çŸ­è·ç¦»
		int t = -1;
		for(int j = 1; j <= n; j++){ //æ‰¾å‡ºéç¡®å®šæœ€çŸ­è·¯çš„ èµ·ç‚¹åˆ°ä¸€ä¸ªç‚¹çš„æœ€çŸ­è·ç¦»çš„ç‚¹ 
			if(!st[j] && (t==-1||dist[j] < dist[t])){
				t = j;
			}
		} 
		//ç”¨å½“å‰è·å–çš„æœ€çŸ­è·¯å¾„è·Ÿæ–°å…¶ä»–å€¼ 
		for(int j = 1; j <= n;j++){
			dist[j] = min(dist[j],dist[t] + g[t][j]);
		}
		st[t] = true; //èµ·ç‚¹åˆ°tç‚¹ç¡®å®šæ­¤ä¸ºæœ€çŸ­è·¯ 
		
	} 
	if(dist[n] == 0x3f3f3f3f) return -1;//æœç´¢ä¸åˆ° //nä¸ºç»ˆç‚¹;å¦‚æœç»ˆç‚¹æ˜¯eå°±å†™e 
	return dist[n]; 
} 



void solve(){
	cin >> n >> m;
	memset(g,0x3f,sizeof g);//åˆå§‹åŒ–é‚»æ¥çŸ©é˜µ 
	while(m--){
		int x,y,v;
		cin >> x >> y >> v;
		g[x][y] = min(g[x][y],v);
	} 
	cout << dis() << endl;

}
```

**ä¼˜å…ˆé˜Ÿåˆ—ä¼˜åŒ–ç‰ˆæœ¬**

//è®°å¾—åˆå§‹åŒ–hä¸º-1!!!!!;

```c++
#include<bits/stdc++.h>
using namespace std;


//é‚»æ¥è¡¨æ¨¡å— 
const int N = 2000005;
const int M = 2000005;
int h[N],e[N],ne[M],w[M],idx;//åˆå§‹åŒ– å­ç»“ç‚¹ æŒ‡å‘èŠ‚ç‚¹  ä¸Šä¸€ä¸ªèŠ‚ç‚¹  æƒå€¼ èŠ‚ç‚¹ä½ç½®

//a->bæƒå€¼ä¸ºval 
void add(int a,int b,int val){
	e[idx] = b;
	w[idx] = val;
	ne[idx] = h[a];
	h[a] = idx++; 
} 

//è¿ªæ°æ–¯ç‰¹æ‹‰å˜é‡æ¨¡å—
int dist[N]; //æ‰€æœ‰ç‚¹åˆ°startç‚¹çš„è·ç¦» 
int st[N];  //å­˜å‚¨æ¯ä¸ªç‚¹çš„æœ€çŸ­è·ç¦»æ˜¯å¦ç¡®å®š 
int start; //åˆå§‹åŒ–æºç‚¹ 
int en;  //éœ€è¦å¯»æ‰¾çš„èŠ‚ç‚¹

//æ‰“å°è·¯å¾„
//int path[N]; ç”¨æ¥ä¿å­˜è·¯å¾„ 


int dijkstra(){
	memset(dist,0x3f,sizeof dist); //é»˜è®¤æ— ç©·å¤§
    memset(st,0,sizeof st);
	dist[start] = 0; //åŸç‚¹åˆ°æœ¬èº«è·ç¦»ä¸º0
	//ä¼˜å…ˆé˜Ÿåˆ— å°æ ¹å † 
	priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> heap; 
	heap.emplace(0,start);//firstè·ç¦» secondèŠ‚ç‚¹ 
	while(!heap.empty()){
		auto t = heap.top();
		heap.pop();
		int node = t.second, dis = t.first;
		if(st[node]) continue; //ä¹‹å‰ç¡®å®šè¿‡å°±æ²¡å¿…è¦å†æ¬¡ç¡®å®šäº†
		st[node] = 1;
		for(int i = h[node]; i!=-1; i = ne[i]){
			int j = e[i]; //nodeæŒ‡å‘çš„èŠ‚ç‚¹
			if(dist[j] > dis + w[i]){
                //path[j] = node;  è·¯å¾„ä¿å­˜ 
				dist[j] = dis + w[i];
				heap.push({dist[j],j}); 
			}
		} 
	}
	if(dist[en] == 0x3f3f3f3f) return -1;
	return dist[en]; 
} 


void solve(){
    int n,m;
    cin >> n >> m;
    memset(h,-1,sizeof h);
    idx = 0;
    for(int i = 0; i < m/2;i++){
        int a,b,v;
        cin >> a >> b >> v;
        add(a,b,v);
        add(b,a,v);
    }
    cin >> start;
    cin >> en;
    
    int g =  dijkstra();
    //è·¯å¾„ä¿å­˜ åå‘éå† e -> så­˜å‚¨çš„ æ‰€ä»¥è¦åè¿‡æ¥éå† 
//    stack<int> stk;
//    int k = en;
//	while(true){
//		if(k==start) break;
//		st.push(path[k]);
//		k = path[k]; 
//	} 
//	while (!stk.empty()) {
//        cout << stk.top() << "-->";
//        stk.pop();
//    }
//    cout << e << ":";
	cout << g <<endl; 

}


signed main(){
	int times = 1;
	//cin >> times;
	while(times--){
		solve();
	}
	return 0;
}
```

##### é‚»æ¥è¡¨ç‰ˆæœ¬

```c++
const int N = 200005;
//è¿ªæ°æ–¯ç‰¹æ‹‰å˜é‡æ¨¡å—
int dist[N]; //æ‰€æœ‰ç‚¹åˆ°startç‚¹çš„è·ç¦» 
int st[N];  //å­˜å‚¨æ¯ä¸ªç‚¹çš„æœ€çŸ­è·ç¦»æ˜¯å¦ç¡®å®š 
int start; //åˆå§‹åŒ–æºç‚¹ 
int en;  //éœ€è¦å¯»æ‰¾çš„èŠ‚ç‚¹

//æ‰“å°è·¯å¾„
//int path[N]; ç”¨æ¥ä¿å­˜è·¯å¾„ 

vector<vector<pair<int,int>>> v(N);
int dijkstra(){
	
	//cout << 1 <<endl;
	memset(dist,0x3f,sizeof dist); //é»˜è®¤æ— ç©·å¤§
    memset(st,0,sizeof st);
	dist[start] = 0; //åŸç‚¹åˆ°æœ¬èº«è·ç¦»ä¸º0
	//ä¼˜å…ˆé˜Ÿåˆ— å°æ ¹å † 
	priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> heap; 
	heap.emplace(0,start);//firstè·ç¦» secondèŠ‚ç‚¹ 
	while(!heap.empty()){
		
		auto t = heap.top();
		heap.pop();
		int node = t.second, dis = t.first;
		if(st[node]) continue; //ä¹‹å‰ç¡®å®šè¿‡å°±æ²¡å¿…è¦å†æ¬¡ç¡®å®šäº†
		st[node] = 1;
		for(auto p : v[node]){
			int j = p.first; //nodeæŒ‡å‘çš„èŠ‚ç‚¹
			
			if(dist[j] > dis + p.second){
                //path[j] = node;  è·¯å¾„ä¿å­˜ 
				dist[j] = dis + p.second;
				heap.push({dist[j],j}); 
			}
		} 
	}
	if(dist[en] == 0x3f3f3f3f) return -1;
	return dist[en]; 
} 

void solve(){
	int n;
	cin >> n;
	for(int i = 1; i < n; i++){
		int a,b,c;
		cin >> a >> b >>c;
		v[i].push_back({i+1,a});
		v[i].push_back({c,b});		
	}
	start = 1;
	en = n;
	cout << dijkstra();
}
```

å‚è€ƒèµ„æ–™:

http://t.csdnimg.cn/gq3nW //ä¼˜å…ˆé˜Ÿåˆ—/æœ´ç´  æ¨¡ç‰ˆ

http://t.csdnimg.cn/bJD8S //æ‰“å°è·¯å¾„

æ•°æ®ç»“æ„ï¼šå›¾çš„å­˜å‚¨ç»“æ„ä¹‹é‚»æ¥è¡¨ - Linuxå†…æ ¸åº“çš„æ–‡ç«  - çŸ¥ä¹
https://zhuanlan.zhihu.com/p/466362219

ä¾‹é¢˜:

[1631. æœ€å°ä½“åŠ›æ¶ˆè€—è·¯å¾„ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/path-with-minimum-effort/solutions/2591106/lian-shi-qian-xiang-xing-cun-tu-dijkstra-j6mi/)

##### å˜å¼

Dijkstra ä¸Šè®¡æ•°

[1976. åˆ°è¾¾ç›®çš„åœ°çš„æ–¹æ¡ˆæ•°](https://leetcode.cn/problems/number-of-ways-to-arrive-at-destination/)

```c++
class Solution {
public:

    int countPaths(int n, vector<vector<int>>& roads) {
        int mod = 1e9+7;
        vector<vector<pair<int,long long>>> edge(n);
        for(auto p:roads){
            edge[p[0]].push_back({p[1],p[2]});
            edge[p[1]].push_back({p[0],p[2]});
        }
        long long dis[n];
        int vis[n];
        long long cnt[n];//å‡ ç§æœ€å°æ–¹å¼åˆ°è¾¾ièŠ‚ç‚¹
        memset(dis,0x3f,sizeof dis);
        memset(vis,0,sizeof vis);
        memset(cnt,0,sizeof cnt);
        cnt[0] = 1;
        dis[0] = 0;
        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>> q;
        q.push({0,0});
        while(!q.empty()){
            auto p = q.top();q.pop();
            long long val = p.first,node = p.second;
            if(vis[node]) continue;
            vis[node] = 1;
            for(auto p:edge[node]){
                long long w = p.second;
                int son = p.first;
                if(dis[son]>w+val){
                    dis[son] = w+val;
                    q.push({dis[son],son});
                    cnt[son] = cnt[node];
                }else if(dis[son] == w+val){
                    cnt[son] = (cnt[son]+cnt[node])%mod;
                }
            }

        }
        return cnt[n-1];
    }
};
```



#### **(2)Floyd**

**å¯ä»¥æ±‚å¸¦è´Ÿæƒè¾¹ä½†ä¸å¸¦è´Ÿç¯å›¾çš„å¤šæºæœ€çŸ­è·¯**

**æ—¶é—´å¤æ‚åº¦(O^3)**

å¦‚æœè¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•åŸºäºè´ªå¿ƒ é‚£ä¹ˆå¼—æ´›ä¼Šå¾·ç®—æ³•æ˜¯ä¸€ç§åŠ¨æ€è§„åˆ’æ€æƒ³

```c++
//ç®—æ³•æ ¸å¿ƒä»£ç 
//å®šä¹‰ä¸€ä¸ªä¸€ä¸ª dist[][]é‚»æ¥çŸ©é˜µ
for(int k = 0; k < n; k++){ //i -> j çš„ä¸­é—´èŠ‚ç‚¹ i -> k -> j
    for(int i = 0; i < n; i++){
        for(int j = 0; j < n; j++){
            dist[i][j] = min(dist[i][j],dis[i][k] + dis[k][j]);
        }
    }
}
```

##### å˜å½¢

åˆ¤æ–­ä¸¤ç‚¹æ˜¯å¦å¯è¾¾

```c++
 for (int k = 0; k < n; ++k) {
    for (int i = 0; i < n; ++ i) {
        for (int j = 0; j < n; ++ j) {
            f[i][j] |= (f[i][k] && f[k][j]);
        }
    }
}
```

##### ä¾‹é¢˜

[1462. è¯¾ç¨‹è¡¨ IV - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/course-schedule-iv/description/)

[851. å–§é—¹å’Œå¯Œæœ‰ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/loud-and-rich/description/)

#### (3)Bellmanâ€“Ford

**å•æºæœ€çŸ­è·¯å¯ä»¥æ±‚å¸¦è´Ÿæƒå›¾çš„æœ€çŸ­è·¯**

æ—¶é—´å¤æ‚åº¦O(NM)

```c++
const int N = 10005;
vector<pair<int,int>> e[N];//é‚»æ¥è¡¨
int dis[N];//è·ç¦»
int start;//èµ·ç‚¹
//bool åˆ¤æ–­æ˜¯å¦æœ‰è´Ÿç¯ 
bool bellman_ford(){
	memset(dis,0x3f,sizeof dis);
	dis[start] = 0;
	bool flag;
	//åˆ¤æ–­ä¸€è½®æ˜¯å¦æœ‰æ¾å¼›æ“ä½œ 
	for(int i = 1; i <= n; i++){
		flag = false;
		for(int u = 1; u <= n;u++){
			if(dis[u] == 0x3f3f3f3f) continue; 
			for(auto ed:e[u]){
				int v = ed.first,node = ed.second;
				if(dis[node] > dis[u] + v){
					dis[node] = dis[u] + v;
					flag = true;
				}
			}
		}
		if(!flag) break; 
	}
	//å¦‚æœnè½®è¿˜æœ‰æ¾å¼› ä»£è¡¨æœ‰è´Ÿç¯ true; 
	return flag;
	
} 
```

#### (4)SPFA

Bellman_Fordè¿›é˜¶ç‰ˆ æ˜¯é˜Ÿåˆ—ä¼˜åŒ–çš„Bellman_Ford

æ—¶é—´å¤æ‚åº¦ä¸ç¨³å®šï¼šåœ¨æœ€åæƒ…å†µä¸‹ï¼ŒSPFA ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦å¯ä»¥è¾¾åˆ° O ( V E ) O(VE)O(VE)ï¼Œå…¶ä¸­ V VV å’Œ E EE åˆ†åˆ«æ˜¯å›¾ä¸­çš„é¡¶ç‚¹æ•°å’Œè¾¹æ•°ã€‚è€Œåœ¨æœ€å¥½æƒ…å†µä¸‹ï¼Œæ—¶é—´å¤æ‚åº¦åªæœ‰ O ( E ) O(E)O(E)ã€‚å› æ­¤ï¼ŒSPFA ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯ä¸ç¨³å®šçš„ã€‚

```c++
const int N = 100005;
int dis[N];
int st[N];//å­˜å‚¨å½“å‰è½®æ¾å¼›è¿‡çš„ 
int cnt[N];
int start; 
int n,m;
vector<pair<int,int>> e[N];
bool spfa(){
	memset(dis,0x3f,sizeof dis);
	memset(st,0,sizeof st);
	queue<int> q;
	q.push(start);
	st[start] = 1;
	dis[start] = 1;
	while(q.size()){
		int u = q.front();q.pop();
		st[u] = 0;//å¯é‡æ–°æ¾å¼› æ ‡è®°è¯¥é¡¶ç‚¹ä¸ºæœªè®¿é—®ï¼Œä»¥ä¾¿åœ¨ç®—æ³•ä¸­å†æ¬¡å¯¹å…¶å¤„ç†
		for(auto ed:e[u]){
			int w = ed.first;
			int node = ed.second;
			if(dis[node] > dis[u] + w){
				dis[node] = dis[u] + w;
				cnt[node] = cnt[u] + 1;
				if(cnt[node] >= n) return false; //ç»è¿‡çš„ç‚¹å¤§äºnå°±æ˜¯è´Ÿç¯
				if(!st[node]){
					st[node] = 1;
					q.push(node);
				}
			}
		} 
	}
	return true;
} 
```

å‚è€ƒé“¾æ¥:

https://blog.csdn.net/MissingPastDay/article/details/130439485

[æœ€çŸ­è·¯ - OI Wiki (oi-wiki.org)](https://oi-wiki.org/graph/shortest-path/)

### 2.æœ€å°ç”Ÿæˆæ ‘

**å…‹é²æ–¯å¡å°”ï¼ˆKruskalï¼‰ç®—æ³•ç”±äºåªä¸è¾¹æœ‰å…³ï¼Œåˆ™åˆé€‚æ±‚ç¨€å°‘å›¾çš„æœ€å°ç”Ÿæˆæ ‘ã€‚è€Œprimeç®—æ³•ç”±äºåªä¸ç«¯ç‚¹ç›¸å…³ï¼Œå› æ­¤åˆé€‚æ±‚è¾ƒå¯†å›¾çš„æœ€å°ç”Ÿæˆæ ‘ã€‚**

#### (1)Kruskal

![image-20240105145804633](img/image-20240105145804633-1704437890383-10.png)

##### ä»£ç 

```c++
const int N = 100005;
struct edge{
	int u,v,w;//èµ·ç‚¹ ç»ˆç‚¹ æƒå€¼
	bool operator<(const edge &t)const{return w < t.w;} 
}e[N];
//faä¸ºå¹¶æŸ¥é›† ansä¸ºæœ€å°ç”Ÿæˆæ ‘çš„å¤§å° cntç”¨æ¥åˆ¤æ–­æ˜¯å¦é€‰å–äº†n-1æ¡è¾¹ å¦‚æœæ²¡æœ‰é€‰åˆ°åˆ™ä¸è”é€š
int n,m; 
int fa[N],ans,cnt;
int find(int x){
	int root = x;
	while(fa[root]!=-1){
		root = fa[root]; 
	} 
	while(x != root){
		int t = fa[x];
		fa[x] = root;
		x = t; 
	} 
	return root; 
} 
bool kruskal(){
	sort(e,e+m);
	for(int i = 0; i < n;i++) fa[i] = -1;//åˆå§‹åŒ–å¹¶æŸ¥é›†
	for(int i = 0; i < m;i++){
		int x = find(e[i].u);
		int y = find(e[i].v);
		//å¦‚æœæ ¹ä¸åŒè¯´æ˜æ²¡æœ‰è”é€šè¿‡ æ•…è”é€š 
		if(x!=y){
			fa[x] = y;
			ans+=e[i].w;
			cnt++; 
		} 
	} 
	return cnt == n-1; 
} 
```

##### å‚è€ƒèµ„æ–™:

[312 æœ€å°ç”Ÿæˆæ ‘ Kruskal ç®—æ³•_å“”å“©å“”å“©_bilibili](https://www.bilibili.com/video/BV1yt4y1H7F9/?spm_id_from=333.999.0.0&vd_source=21eac5088925735ea6d1be13cecd34d8)

[æœ€å°ç”Ÿæˆæ ‘ - OI Wiki (oi-wiki.org)](https://oi-wiki.org/graph/mst/)

#### (2)Prim

é™¤äº† `Kruskal` ç®—æ³•ä»¥å¤–ï¼Œæ™®é‡Œå§†ç®—æ³•ï¼ˆ`Prim` ç®—æ³•ï¼‰ä¹Ÿæ˜¯å¸¸ç”¨çš„æœ€å°ç”Ÿæˆæ ‘ç®—æ³•ã€‚è™½ç„¶åœ¨æ•ˆç‡ä¸Šå·®ä¸å¤šã€‚ä½†æ˜¯è´ªå¿ƒçš„æ–¹å¼å’Œ `Kruskal` å®Œå…¨ä¸åŒã€‚prim ç®—æ³•çš„æ ¸å¿ƒä¿¡ä»°æ˜¯ï¼š**ä»å·²çŸ¥æ‰©æ•£å¯»æ‰¾æœ€å°**ã€‚å®ƒçš„å®ç°æ–¹å¼å’Œ [`Dijkstra`](https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg2MTE1NjA2Mg%3D%3D%26mid%3D2247483971%26idx%3D1%26sn%3D08ae0369734aa67e19287b1679be5ed1%26chksm%3Dce1a25f2f96dace4436194b3ff4333a959f7e400cf2ca8c9c01b0bfc734c4fa3e2309ce9fa78%26scene%3D21%23wechat_redirect)ç®—æ³•ç›¸ä¼¼ä½†ç¨å¾®æœ‰æ‰€åŒºåˆ«ï¼ŒDijkstra æ˜¯æ±‚å•æºæœ€çŸ­è·¯å¾„ã€‚è€Œæ¯è®¡ç®—ä¸€ä¸ªç‚¹éœ€è¦å¯¹è¿™ä¸ªç‚¹ä»æ–°æ›´æ–°è·ç¦»ã€‚è€Œ prim ç”šè‡³ä¸ç”¨æ›´æ–°è·ç¦»ã€‚**ç›´æ¥æ‰¾å·²çŸ¥ç‚¹çš„é‚»è¾¹æœ€å°åŠ å…¥**å³å¯ï¼

å¯¹äºå…·ä½“ç®—æ³•å…·ä½“æ­¥éª¤ï¼Œå¤§è‡´ä¸ºï¼š

1. å¯»æ‰¾å›¾ä¸­**ä»»æ„ç‚¹**ï¼Œä»¥å®ƒä¸ºèµ·ç‚¹ï¼Œå®ƒçš„**æ‰€æœ‰è¾¹ V åŠ å…¥é›†åˆ (ä¼˜å…ˆé˜Ÿåˆ—)**`q1`, è®¾ç½®ä¸€ä¸ª `booleanæ•°ç»„bool[]` æ ‡è®°è¯¥ä½ç½®å·²ç»ç¡®å®šã€‚
2. ä»é›†åˆ q1 æ‰¾åˆ°**è·ç¦»æœ€å°**çš„é‚£ä¸ªè¾¹ `v1` å¹¶**åˆ¤æ–­è¾¹å¦ä¸€ç‚¹ p æ˜¯å¦è¢«æ ‡è®° (è®¿é—®)**ï¼Œå¦‚æœ `p` è¢«æ ‡è®°è¯´æ˜å·²ç»ç¡®å®šé‚£ä¹ˆè·³è¿‡ï¼Œå¦‚æœæœªè¢«æ ‡ (è®¿é—®) è®°é‚£ä¹ˆæ ‡è®°è¯¥ç‚¹ `p`, å¹¶ä¸”**ä¸ p ç›¸è¿çš„æœªçŸ¥ç‚¹ (æœªè¢«æ ‡è®°) æ„æˆçš„è¾¹**åŠ å…¥é›†åˆ `q1`ï¼Œ**è¾¹ v1 (å¯ä»¥è¿›è¡Œè®¡ç®—è·ç¦»ä¹‹ç±»ï¼Œè¯¥è¾¹æ„æˆæœ€å°ç”Ÿæˆæ ‘)** .
3. é‡å¤ 1ï¼Œ2 ç›´åˆ° q1 ä¸ºç©ºï¼Œæ„æˆæœ€å°ç”Ÿæˆæ ‘ ï¼

##### ä»£ç 

```c++
int cnt = 0;
const int N = 100005;
int dis[N];
int vis[N];
int ans = 0;
int start = 1;
void prim(){
	memset(dis,0x3f,sizeof dis);
	memset(vis,0,sizeof vis);
	priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;
	q.push({0,start});
	dis[start] = 0;
	while(!q.empty()){
		if(cnt>=n) break;
		auto p = q.top();q.pop();
		int val = p.first;
		int node = p.second;
		if(vis[node]) continue;
        ++cnt;
		vis[node] = 1;
		ans+=val;
		//cout << ans << endl;
		for(int i = h[node]; i != -1;i = ne[i]){
			int j = e[i];
			int w1 = w[i];
			if(dis[j] > w1){
				dis[j] = w1; //æ›´æ–°çš„æ˜¯è¾¹çš„é•¿åº¦
				q.push({dis[j],j});
			} 
		}
	}
}
```



### 3.è¿é€šæ€§é—®é¢˜

#### (1)å¼ºè”é€šåˆ†é‡

æ¦‚å¿µ

å¼ºè¿é€šçš„å®šä¹‰æ˜¯ï¼šæœ‰å‘å›¾ G å¼ºè¿é€šæ˜¯æŒ‡ï¼ŒG ä¸­ä»»æ„ä¸¤ä¸ªç»“ç‚¹è¿é€šã€‚

å¼ºè¿é€šåˆ†é‡ï¼ˆStrongly Connected Componentsï¼ŒSCCï¼‰çš„å®šä¹‰æ˜¯ï¼š**æå¤§**çš„å¼ºè¿é€šå­å›¾ã€‚

![image-20240110192255492](img/image-20240110192255492-1704885805042-4.png)

##### **1.Tarjan**

å¡”æ¨ç®—æ³•

![image-20240122203042381](img/image-20240122203042381.png)

![image-20240110192615793](img/image-20240110192615793.png)

æ—¶é—´å¤æ‚åº¦O(n+m);

**ç²¾é«“ å…¥ å› ç¦»**

###### åŸºç¡€**ä»£ç **

```c++
const int N = 100005;
int dfn[N],low[N],tot = 0; //æ—¶é—´æˆ³,æœ€å°è¿½æº¯å€¼,ç¼–å· 
int stk[N],instk[N],top = 0; //æ ˆ,æ˜¯å¦åœ¨æ ˆ,ç¼–å· 
int scc[N],siz[N],cnt = 0; //å¼ºè”é€šåˆ†é‡è¡¨,æ¯ä¸ªå¼ºè”é€šåˆ†é‡çš„å¤§å°,ç¼–å·
vector<vector<int>> edge(N); 
int n,m; //ç‚¹æ•°,è¾¹æ•° 
//xä¸ºæ¯ä¸ªèŠ‚ç‚¹ 
void tarjan(int x){
	//å…¥çš„æ“ä½œ
	dfn[x]=low[x]=++tot; //ç¼–å·éƒ½ç»Ÿä¸€ä»1å¼€å§‹
	stk[++top] = x,instk[x] = 1;
	for(int y:edge[x]){
		//å¦‚æœæ²¡æœ‰æ—¶é—´æˆ³ å°±ç»§ç»­èµ° èµ°åˆ°åº• èµ°å®Œäº†å¾€å›å¸¦å€¼ 
		if(!dfn[y]){
			tarjan(y);
			low[x] = min(low[x],low[y]); //æ›´æ–° 
		}else if(instk[y]){                   //å¦‚æœæ‹¥æœ‰å¹¶ä¸”åœ¨æ ˆä¸­ è¯´æ˜æ˜¯ç¥–å…ˆèŠ‚ç‚¹æˆ–åŒè¾ˆèŠ‚ç‚¹ è·Ÿæ–°low 
			low[x] = min(low[x],dfn[y]); 
		} 
		//è¿˜æœ‰å°±æ˜¯æœ‰dfnæ—¶é—´æˆ³ ä½†æ˜¯ä¸åœ¨æ ˆä¸­ ä¸æ‰§è¡Œæ“ä½œ ç¨‹åºä¼š\è·³è¿‡,å› ä¸ºè¿™ç§æƒ…å†µè¿™ä¸ªyå€¼æ˜¯å±äºäº†
		//å¦ä¸€ä¸ªå¼ºè”é€šåˆ†é‡,æ‰€ä»¥ä¸æ“ä½œå°±è¡Œäº†,ç¨‹åºä¼šè‡ªåŠ¨å›æº¯; 
	}
	//èµ°å›æ¥å‘ç° è‡ªå·±å°±æ˜¯æœ€å°æ—¶é—´æˆ³,é‚£ä¹ˆå°±ç¡®å®šsccç»„æ˜¯è‡ªå·±ä»¥åŠåˆšéå†å‡ºå»çš„èŠ‚ç‚¹; 
	if(dfn[x] == low[x]){
		int y;++cnt; //1ç¼–å·å¼€å§‹; 
		 while(true){
		 	y = stk[top--];
		 	instk[y] = 0;
		 	scc[y] = cnt;
		 	++siz[cnt];
		 	if(y==x){
		 		break;
			 }
		 }
	} 	 
} 
```

###### **æ¨¡å‹**

######  1.ç¼©ç‚¹

![image-20240111190242165](img/image-20240111190242165.png)

![image-20240111202332875](img/image-20240111202332875.png)

###### 2.å‰²ç‚¹

![image-20240116200734740](img/image-20240116200734740.png)

![image-20240116203130829](img/image-20240116203130829.png)

**ä»£ç **

```c++
const int N = 100005;
vector<int> e[N];
int dfn[N],low[N],tot;
int cut[N],root;
void tarjan(int x){
	dfn[x] = low[x] = ++tot;
	int child = 0;
	for(int y:e[x]){
		if(!dfn[y]){
			tarjan(y);
			low[x] = min(low[y],low[x]);
			if(low[y]>=dfn[x]){
				child++;
				if(x!=root||child>1){
					cut[x] = 1;
				}
			}
		}else{ //å·²ç»è®¿é—®è¿‡ 
			low[x] = min(low[x],dfn[y]);
		}
	}
}
```

```c++
//éå†ç‚¹
for(int i = 1; i <= n;i++){
    if(!dfn[i]){
        root = i;
        tarjan(i);
    }
}
```

###### 3.å‰²è¾¹

![image-20240117130521893](img/image-20240117130521893.png)

**å› ä¸ºè¦åˆ¤æ–­åè¾¹æ‰€ä»¥ä¸èƒ½ç”¨ç®€å•çš„é‚»æ¥è¡¨è¡¨è¾¾,åº”è¯¥ç”¨é“¾å¼å‰å‘æ˜Ÿå­˜å›¾**

**ä»£ç **:

```c++
int h[N],e[N],ne[N],idx;
vector<pair<int,int>> bridge;
void add(int a,int b){
	e[idx] = b;
	ne[idx] = h[a];
	h[a] = idx++;
}
int dfn[N],low[N],tot;
void tarjan(int x,int edge){
	dfn[x] = low[x] = ++tot;
	for(int i = h[x]; i != -1; i = ne[i]){
		int y = e[i];
		if(!dfn[y]){
			tarjan(y,i);
			low[x] = min(low[x],low[y]);
			if(dfn[x] < low[y]){
				bridge.push_back({x,y});
			} 
		}else if(i!=(edge^1)){
			low[x] = min(low[x],dfn[y]);
		} 
		
	}
}
```

ä¾‹é¢˜:

CF427C ç¼©ç‚¹

æ´›è°·2863

æ´›è°·3387 ç®€å•dp+sccç¼©ç‚¹

æ´›è°·2812 ç®€å•å‡ºåº¦å…¥åº¦åˆ¤æ–­

æ´›è°·3388 å‰²ç‚¹é—®é¢˜

æ´›è°·1656 éš”è¾¹é—®é¢˜ 

è§ä¸‹ ç®€å•å‡ºåº¦å…¥åº¦åˆ¤æ–­

###### **ä¾‹é¢˜**

###### æ´›è°·2863

[P2863 [USACO06JAN\] The Cow Prom S - æ´›è°· | è®¡ç®—æœºç§‘å­¦æ•™è‚²æ–°ç”Ÿæ€ (luogu.com.cn)](https://www.luogu.com.cn/problem/P2863)

ä»£ç 

```c++
const int N = 100005;
int dfn[N],low[N],tot=0;
int stk[N],instk[N],top=0;
int scc[N],siz[N],cnt=0;
vector<vector<int>> edge(10005); 
void tarjan(int x){
	dfn[x]=low[x]=++tot;
	stk[++top] = x, instk[x] = 1;
	//cout << x <<endl;
	for(auto y:edge[x]){
		if(!dfn[y]){
			tarjan(y);
			low[x] = min(low[x],low[y]);
		}else if(instk[y]){
			low[x] = min(dfn[y],low[x]);
		}
	}
	
	if(dfn[x]==low[x]){
		int y;
		cnt++;
		while(true){
			y = stk[top];
			instk[y] = 0;
			top--;
			
			scc[y] = cnt;
			siz[cnt]++;
			
			if(y==x){
				break;
			}
		}
	}
} 

int gin[N],gout[N];
void solve(){
	
	int n;
	cin >> n;
	for(int i = 1; i <= n;i++){
		int a;
		while(cin>> a,a)
			edge[i].push_back(a);
	}
	
	for(int i = 1; i <= n; i++){
		if(!dfn[i]) tarjan(i);
	}
	for(int i = 1; i <= n;i++){
		for(auto y:edge[i]){
			if(scc[y]!=scc[i]){
				gin[scc[y]]++;
				gout[scc[i]]++; 
			}
		}
	}
	int a = 0, b = 0;
	for(int i = 1; i <= cnt;i++){
		if(!gin[i]) a++;
		if(!gout[i]) b++;
	}
	cout << a << endl;
	if(cnt==1){
		cout << 0 <<endl;
		return;
	}
	cout << max(a,b) << endl;

}
```



###### æ´›è°·2812

ä»£ç 

```c++
const int N = 100005;
int dfn[N],low[N],tot = 0; //æ—¶é—´æˆ³,æœ€å°è¿½æº¯å€¼,ç¼–å· 
int stk[N],instk[N],top = 0; //æ ˆ,æ˜¯å¦åœ¨æ ˆ,ç¼–å· 
int scc[N],siz[N],cnt = 0; //å¼ºè”é€šåˆ†é‡è¡¨,æ¯ä¸ªå¼ºè”é€šåˆ†é‡çš„å¤§å°,ç¼–å·
vector<vector<int>> edge(N); 
int n,m; //ç‚¹æ•°,è¾¹æ•° 
//xä¸ºæ¯ä¸ªèŠ‚ç‚¹ 
void tarjan(int x){
	//å…¥çš„æ“ä½œ
	dfn[x]=low[x]=++tot; //ç¼–å·éƒ½ç»Ÿä¸€ä»1å¼€å§‹
	stk[++top] = x,instk[x] = 1;
	for(int y:edge[x]){
		//å¦‚æœæ²¡æœ‰æ—¶é—´æˆ³ å°±ç»§ç»­èµ° èµ°åˆ°åº• èµ°å®Œäº†å¾€å›å¸¦å€¼ 
		if(!dfn[y]){
			tarjan(y);
			low[x] = min(low[x],low[y]); //æ›´æ–° 
		}else if(instk[y]){                   //å¦‚æœæ‹¥æœ‰å¹¶ä¸”åœ¨æ ˆä¸­ è¯´æ˜æ˜¯ç¥–å…ˆèŠ‚ç‚¹æˆ–åŒè¾ˆèŠ‚ç‚¹ è·Ÿæ–°low 
			low[x] = min(low[x],dfn[y]); 
		} 
		//è¿˜æœ‰å°±æ˜¯æœ‰dfnæ—¶é—´æˆ³ ä½†æ˜¯ä¸åœ¨æ ˆä¸­ ä¸æ‰§è¡Œæ“ä½œ ç¨‹åºä¼š\è·³è¿‡,å› ä¸ºè¿™ç§æƒ…å†µè¿™ä¸ªyå€¼æ˜¯å±äºäº†
		//å¦ä¸€ä¸ªå¼ºè”é€šåˆ†é‡,æ‰€ä»¥ä¸æ“ä½œå°±è¡Œäº†,ç¨‹åºä¼šè‡ªåŠ¨å›æº¯; 
	}
	//èµ°å›æ¥å‘ç° è‡ªå·±å°±æ˜¯æœ€å°æ—¶é—´æˆ³,é‚£ä¹ˆå°±ç¡®å®šsccç»„æ˜¯è‡ªå·±ä»¥åŠåˆšéå†å‡ºå»çš„èŠ‚ç‚¹; 
	if(dfn[x] == low[x]){
		int y;++cnt; //1ç¼–å·å¼€å§‹; 
		 while(true){
		 	y = stk[top--];
		 	instk[y] = 0;
		 	scc[y] = cnt;
		 	++siz[cnt];
		 	if(y==x){
		 		break;
			 }
		 }
	}  
} 
void solve(){
	cin >> n >> m;
	for(int i = 0; i < m;i++){
		int a,b;
		cin >> a >> b;
		edge[a].push_back(b);
	}
	memset(instk,0,sizeof instk);
	memset(dfn,0,sizeof dfn);
	for(int i = 1; i <= n;i++){ //æ‰¾æ¯ä¸€ä¸ªæœªæ ‡è®°èŠ‚ç‚¹çš„scc 
		if(!dfn[i]){
			tarjan(i);
		}
	}
	int res = 0; 
	for(int i = 1; i<= cnt;i++){
		if(siz[i]>1) res++; 
	} 
	cout << res; 
}
```

###### **æ´›è°·3387**

```c++
const int N = 100005;
int dfn[N],low[N],tot=0;
int stk[N],instk[N],top=0;
int siz[N],scc[N],cnt=0;
vector<vector<int>> edge(N);
void Tarjan(int x){
	dfn[x] = low[x] = ++tot;
	stk[++top] = x,instk[x] = 1;
	for(int y:edge[x]){
		if(!dfn[y]){
			Tarjan(y);
			low[x] = min(low[x],low[y]);
		}else if(instk[y]){
			low[x] = min(dfn[y],low[x]);	
		}
	}
	if(dfn[x]==low[x]){
		int y;
		++cnt;
		while(true){
			y = stk[top];
			top--;
			instk[y]=0;
			scc[y] = cnt;
			siz[cnt]++;
			if(y==x) break;
		}
	}
}
void solve(){
	int n,m;
	cin >> n >> m;
	int a[n+1];
	for(int i = 1; i <= n; i++) cin >> a[i];
	for(int i = 0; i <m; i++){
		int u,v;
		cin >> u >> v;
		edge[u].push_back(v);
	}
	for(int i = 1; i <= n;i++){
		if(!dfn[i]) Tarjan(i);
	}
	int value[n+1]={0};
	for(int i = 1;i<=n;i++){
		value[scc[i]]+=a[i];
	}
	vector<set<int>> edge2(cnt+1);
	for(int i = 1; i<=n;i++){
		for(int j:edge[i]){
			if(scc[i]!=scc[j]){
				edge2[scc[i]].insert(scc[j]);
			}
		}
	}
	int res = 0;
	int dp[cnt+1]={0}; //æœ‰å¾ˆå¤šä¸ªsccæŒ‡å‘ä¸€ä¸ªscc æ‰€ä»¥è¦ç”¨ä¸€ä¸ªç®€å•çš„dp 
	
	for(int i =cnt; i >= 1; i--){ //å› ä¸ºæœ€æ—©çš„ç‚¹ç¼–å·æœ€å¤§ é€’å½’ç‰¹æ€§ 
		if(dp[i]==0){
			dp[i] = value[i];
		}
		for(int j:edge2[i]){
			dp[j] = max(dp[j],value[j]+dp[i]);
			
		}
		
	}
	for(int i = 1; i <= cnt;i++)  res = max(dp[i],res);
	cout << res;
}

```

###### æ´›è°·1656

```c++
int n,m;
int h[N],e[N],ne[N],idx;
vector<pair<int,int>> bridge;
void add(int a,int b){
	e[idx] = b;
	ne[idx] = h[a];
	h[a] = idx++;
}
int dfn[N],low[N],tot;
bool cmp(pair<int,int> a,pair<int,int> b){
	if(a.first==b.first) return a.second < b.second;
	return a.first<b.first;
}
void tarjan(int x,int edge){
	dfn[x] = low[x] = ++tot;
	for(int i = h[x]; i != -1; i = ne[i]){
		int y = e[i];
		if(!dfn[y]){
			tarjan(y,i);
			low[x] = min(low[x],low[y]);
			if(dfn[x] < low[y]){
				bridge.push_back({x,y});
			} 
		}else if(i!=(edge^1)){
			low[x] = min(low[x],dfn[y]);
		} 
		
	}
}

void solve(){
	memset(h,-1,sizeof h);
	cin >> n >> m;
	for(int i = 0; i < m; i++){
		int a,b;
		cin >> a >> b;
		add(a,b);
		add(b,a);
	}
	for(int i = 1; i <= n; i++){
		if(!dfn[i]) tarjan(i,-1);
	}
	sort(bridge.begin(),bridge.end(),cmp);
	for(auto p:bridge){
		cout << p.first << " " << p.second << endl;
	}

}
```



### 4.æ‹“æ‰‘æ’åº

**åœ¨å›¾è®ºä¸­ï¼Œæ‹“æ‰‘æ’åºæ˜¯ä¸€ä¸ªæœ‰å‘æ— ç¯å›¾ï¼ˆDAGï¼‰çš„æ‰€æœ‰é¡¶ç‚¹çš„çº¿æ€§åºåˆ—ã€‚è€Œä¸”è¯¥åºåˆ—å¿…é¡»æ»¡è¶³ä¸‹é¢ä¸¤ä¸ªæ¡ä»¶ï¼š**

- **æ¯ä¸ªé¡¶ç‚¹åªèƒ½å‡ºç°ä¸€æ¬¡ã€‚ å³å¦‚æœå­˜åœ¨ä¸€æ¡Aåˆ°Bçš„è·¯å¾„ï¼Œé‚£ä¹ˆAèŠ‚ç‚¹åœ¨BèŠ‚ç‚¹å‰é¢ï¼Œé‚£ä¹ˆBèŠ‚ç‚¹ä¸èƒ½åœ¨AèŠ‚ç‚¹å‰é¢ã€‚**
- **åªæœ‰æœ‰å‘æ— ç¯å›¾æ‰æœ‰æ‹“æ‰‘æ’åºï¼Œå¦‚æœä¸æ˜¯DAGå›¾çš„è¯å°±æ²¡æœ‰æ‹“æ‰‘æ’åºã€‚**

#### (1)Kahnç®—æ³•

##### æ€æƒ³

Kahnçš„ç®—æ³•çš„æ€è·¯å…¶å®å°±æ˜¯æˆ‘ä»¬ä¸Šé¢å±•ç¤ºçš„æ‹“æ‰‘æ’åºçš„å®ç°ï¼Œæˆ‘ä»¬å…ˆä½¿ç”¨ä¸€ä¸ªæ ˆä¿å­˜å…¥åº¦ä¸º0çš„é¡¶ç‚¹ï¼Œç„¶åè¾“å‡ºæ ˆé¡¶å…ƒç´ å¹¶ä¸”å°†å’Œæ ˆé¡¶å…ƒç´ æœ‰å…³çš„è¾¹åˆ é™¤ï¼Œå‡å°‘å’Œæ ˆé¡¶å…ƒç´ æœ‰å…³çš„é¡¶ç‚¹çš„å…¥åº¦æ•°é‡å¹¶ä¸”æŠŠå…¥åº¦å‡å°‘åˆ°0çš„é¡¶ç‚¹ä¹Ÿå…¥æ ˆã€‚

##### ä»£ç 

```c++
int n, m;
vector<int> G[MAXN];
int in[MAXN];  // å­˜å‚¨æ¯ä¸ªç»“ç‚¹çš„å…¥åº¦

bool toposort() {
  vector<int> L;
  queue<int> S;
  for (int i = 1; i <= n; i++)
    if (in[i] == 0) S.push(i);
  while (!S.empty()) {
    int u = S.front();
    S.pop();
    L.push_back(u);
    for (auto v : G[u]) {
      if (--in[v] == 0) {
        S.push(v);
      }
    }
  }
  if (L.size() == n) {
    for (auto i : L) cout << i << ' ';
    return true;
  } else {
    return false;
  }
}
```

##### ä¾‹é¢˜ 

1.æœ€çŸ­å·¥æœŸ //å…³é”®è·¯å¾„é—®é¢˜ f[p] = max(f[p],f[fa]+w);

ä¸€ä¸ªé¡¹ç›®ç”±è‹¥å¹²ä¸ªä»»åŠ¡ç»„æˆï¼Œä»»åŠ¡ä¹‹é—´æœ‰å…ˆåä¾èµ–é¡ºåºã€‚é¡¹ç›®ç»ç†éœ€è¦è®¾ç½®ä¸€ç³»åˆ—é‡Œç¨‹ç¢‘ï¼Œåœ¨æ¯ä¸ªé‡Œç¨‹ç¢‘èŠ‚ç‚¹å¤„æ£€æŸ¥ä»»åŠ¡çš„å®Œæˆæƒ…å†µï¼Œå¹¶å¯åŠ¨åç»­çš„ä»»åŠ¡ã€‚ç°ç»™å®šä¸€ä¸ªé¡¹ç›®ä¸­å„ä¸ªä»»åŠ¡ä¹‹é—´çš„å…³ç³»ï¼Œè¯·ä½ è®¡ç®—å‡ºè¿™ä¸ªé¡¹ç›®çš„æœ€æ—©å®Œå·¥æ—¶é—´ã€‚

 **è¾“å…¥æ ¼å¼ï¼š**

é¦–å…ˆç¬¬ä¸€è¡Œç»™å‡ºä¸¤ä¸ªæ­£æ•´æ•°ï¼šé¡¹ç›®é‡Œç¨‹ç¢‘çš„æ•°é‡ *N*ï¼ˆâ‰¤100ï¼‰å’Œä»»åŠ¡æ€»æ•° *M*ã€‚è¿™é‡Œçš„é‡Œç¨‹ç¢‘ä» 0 åˆ° *N*âˆ’1 ç¼–å·ã€‚éšå *M* è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€é¡¹ä»»åŠ¡çš„æè¿°ï¼Œæ ¼å¼ä¸ºâ€œä»»åŠ¡èµ·å§‹é‡Œç¨‹ç¢‘ ä»»åŠ¡ç»“æŸé‡Œç¨‹ç¢‘ å·¥ä½œæ—¶é•¿â€ï¼Œä¸‰ä¸ªæ•°å­—å‡ä¸ºéè´Ÿæ•´æ•°ï¼Œä»¥ç©ºæ ¼åˆ†éš”ã€‚

 **è¾“å‡ºæ ¼å¼ï¼š**

å¦‚æœæ•´ä¸ªé¡¹ç›®çš„å®‰æ’æ˜¯åˆç†å¯è¡Œçš„ï¼Œåœ¨ä¸€è¡Œä¸­è¾“å‡ºæœ€æ—©å®Œå·¥æ—¶é—´ï¼›å¦åˆ™è¾“å‡º"Impossible"ã€‚

 **è¾“å…¥æ ·ä¾‹ 1ï¼š**

```in
9 12
0 1 6
0 2 4
0 3 5
1 4 1
2 4 1
3 5 2
5 4 0
4 6 9
4 7 7
5 7 4
6 8 2
7 8 4
```
**è¾“å‡ºæ ·ä¾‹ 1ï¼š**

```out
18
```

**ä»£ç **

```c++
const int N = 100005;
int n,m;
vector<pair<int,int>> e[N]; 
int in[N]; //å…¥åº¦ 
int ans = 0;
int f[1000];//æ¯ä¸ªç‚¹å®Œæˆçš„æœ€çŸ­æ—¶é—´
int cnt = 0;
void kahn(){
	memset(f,0,sizeof(f));
	queue<int> q;
	for(int i = 0; i < n; i++){
		if(in[i]==0){
			q.push(i);
		}
	} 
	while(!q.empty()){
		int node = q.front();q.pop();
		cnt++;
		for(auto p:e[node]){
			f[p.first] = max(f[node]+p.second,f[p.first]);//æ±‚çš„æ˜¯æ‰€æœ‰ç‚¹åˆ°è¯¥ç‚¹çš„æœ€å¤§è·ç¦»,å¯åŒæ—¶èµ°è¯¥è·¯å¾„
            //cout << f[p.first];
			ans = max(f[p.first],ans);
			in[p.first]--;
			if(in[p.first]==0){
				q.push(p.first);
			}
		}
	}
}


void solve(){
	cin >> n >> m;
	memset(in,0,sizeof in);
	for(int i = 0; i < m; i++){
		int a,b,c;
		cin >> a >> b >> c;
		e[a].push_back({b,c});
		in[b]++; 
	}
	kahn();
    if(cnt!=n){
        cout << "Impossible" <<endl;
        return;
    }
	cout << ans;

}
```

**å‚è€ƒèµ„æ–™**

å…³é”®è·¯å¾„:[ä½ ä¸€å®šçœ‹å¾—æ‡‚çš„å…³é”®è·¯å¾„æ¦‚å¿µ - çŸ¥ä¹ (zhihu.com)](https://zhuanlan.zhihu.com/p/170603727)

[PTAæœ€çŸ­å·¥æœŸ è¯¦ç»†è§£é‡Š ä¸ºä»€ä¹ˆæœ€çŸ­åè€Œæ˜¯æœ€é•¿ï¼Ÿ_ä¸€ä¸ªé¡¹ç›®ç”±è‹¥å¹²ä¸ªä»»åŠ¡ç»„æˆ,ä»»åŠ¡ä¹‹é—´æœ‰å…ˆåä¾èµ–é¡ºåºã€‚é¡¹ç›®ç»ç†éœ€è¦è®¾ç½®ä¸€ç³»åˆ—é‡Œç¨‹-CSDNåšå®¢](https://blog.csdn.net/m0_62150955/article/details/127678897)[PTAæœ€çŸ­å·¥æœŸ è¯¦ç»†è§£é‡Š ä¸ºä»€ä¹ˆæœ€çŸ­åè€Œæ˜¯æœ€é•¿ï¼Ÿ_ä¸€ä¸ªé¡¹ç›®ç”±è‹¥å¹²ä¸ªä»»åŠ¡ç»„æˆ,ä»»åŠ¡ä¹‹é—´æœ‰å…ˆåä¾èµ–é¡ºåºã€‚é¡¹ç›®ç»ç†éœ€è¦è®¾ç½®ä¸€ç³»åˆ—é‡Œç¨‹-CSDNåšå®¢](https://blog.csdn.net/m0_62150955/article/details/127678897)

2.[851. å–§é—¹å’Œå¯Œæœ‰](https://leetcode.cn/problems/loud-and-rich/) //æ‹“æ‰‘æ’åºå†…éƒ¨åšæ¯”è¾ƒ

3.[2192. æœ‰å‘æ— ç¯å›¾ä¸­ä¸€ä¸ªèŠ‚ç‚¹çš„æ‰€æœ‰ç¥–å…ˆ](https://leetcode.cn/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/) //æ‹“æ‰‘æ’åºåšå¯è¾¾æ€§ä¼˜åŒ– å½“ç„¶flyedä¹Ÿå¯ä»¥åˆ¤æ–­å¯è¾¾æ€§;ä½†æ˜¯æ‹“æ‰‘æ’åºçš„é€Ÿåº¦æ›´å¿«

### 5.ç½‘ç»œæµ

![image-20240422144530144](img/image-20240422144530144.png)

![image-20240422152537361](img/image-20240422152537361.png)

#### 1.EKç®—æ³•

![image-20240423135055498](img/image-20240423135055498.png)

**ä»£ç :**

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N = 1e5+7;
//é“¾å¼å‰å‘æ˜Ÿç”¨äºæ‰¾åè¾¹,è®°å¾—åˆå§‹åŒ–hæ•°ç»„ä¸º-1;
struct edge
{
	int v,w,ne;
} e[N << 1];
int h[N],idx = 0;
void add(int u,int v,int w){
	e[idx] = {v,w,h[u]};
	h[u] = idx++;
}
int n,m,s,t;
int mf[N],pre[N]; //mfè¡¨ç¤ºs-tçš„æµé‡ä¸Šçº¿; preè¡¨ç¤ºiçš„å‰é©±èŠ‚ç‚¹
bool bfs(){
	memset(mf,0,sizeof mf);
	queue<int> q;
	q.push(s);
	mf[s] = 1e9;
	while(q.size()){
		int u = q.front();q.pop();
		for(int i = h[u];~i;i=e[i].ne){
			int w = e[i].w;
			int v = e[i].v;
			if(mf[v]==0 && w){ //å¯ä»¥èµ°ä¸”æœªè¢«è®¿é—®
				mf[v] = min(mf[u],w);
				pre[v] = i;
				q.push(v);
				if(v==t) return true;
			}
		}
	}
	return false;
}
ll ek(){
	ll flow = 0;
	while(bfs()){
		int v = t;
		while(v!=s){
			int i = pre[v];
			e[i].w -= mf[t];
			e[i ^ 1].w += mf[t];
			v = e[i ^ 1].v;
		}
		flow+=mf[t];
		//cout << flow << endl;
	}

	return flow;
}
int main(){
	cin >> n >> m >> s >> t;
	memset(h,-1,sizeof h);
	for(int i = 0; i < m;i++){
		int u,v,w;
		cin >> u >> v >> w;
		add(u,v,w);
		add(v,u,0);
	}
	cout << ek();
}
```

#### 2.dinicç®—æ³•

![image-20240423151444659](img/image-20240423151444659.png)

```c++
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int N = 1e5+7;
struct edge{
	int v,w,ne;
}e[N];
int h[N],idx = 0;
void add(int u,int v,int w){
	e[idx] = {v,w,h[u]};
	h[u] = idx++;
}
int n,m,s,t;
int d[N],cur[N];//æ·±åº¦,å½“å‰å¼§
bool bfs(){
	memset(d,0,sizeof d);
	queue<int> q;
	q.push(s);
	d[s] = 1;
	while(q.size()){
		int u = q.front();q.pop();
		for(int i = h[u];~i;i = e[i].ne){
			int v = e[i].v;
			int w = e[i].w;
			if(d[v]==0 && w){
				d[v] = d[u] + 1;
				q.push(v);
				if(v==t) return true;
			}
		}
	}
	return false;
}
ll dfs(int u,int mf){
	if(u==t) return mf;
	ll sum = 0;
	for(int i = cur[u];~i;i=e[i].ne){
		cur[u] = i;//å¼§ä¼˜åŒ–
		int v = e[i].v;
		if(d[v]==d[u]+1 && e[i].w){
			ll f = dfs(v,min(mf,e[i].w));
			e[i].w-=f;
			e[i^1].w+=f;
			sum+=f;
			mf-=f;
			if(mf==0) break; //ä½™é‡ä¼˜åŒ–
		}
	}
	if(sum==0) d[u] = 0; //æ®‹æä¼˜åŒ–
	return sum;
}
ll dinic(){
	ll flow = 0;
	while(bfs()){
		memcpy(cur,h,sizeof h);
		flow+=dfs(s,1e9);
	}
	return flow;
}
int main(){
	memset(h,-1,sizeof h);
	cin >> n >> m >> s >> t;
	for(int i = 0; i < m;i++){
		int u,v,w;
		cin >> u >> v >> w;
		add(u,v,w);
		add(v,u,0);
	}
	cout << dinic();
}
```

### 6.äºŒåˆ†å›¾

#### 1.æŸ“è‰²æ³•åˆ¤å›¾

![image-20240422135022456](img/image-20240422135022456.png)

**åŸç†æ˜¯æŸ“è‰²åˆ¤æ–­å¥‡ç¯**

**ä»£ç :**

```c++
//æ¥è‡ªåŠ›æ‰£: https://leetcode.cn/problems/is-graph-bipartite/
bool isBipartite(vector<vector<int>>& graph) {
        int n = graph.size();
        int color[n + 1];
        memset(color,0,sizeof color);
        function<bool(int,int)> dfs = [&](int u,int c)->bool{
            color[u] = c;
            for(auto p:graph[u]){
                if(!color[p]){
                    if(dfs(p,3 - c)) return true;
                }else{
                    if(color[p]==c) return true;
                }
            }
            return false;
        };
        bool f;
        for(int i = 0; i < n;i++){
            if(!color[i]){
                if(dfs(i,1)) return false;
            }
        }
        return true;
    }
```

**ä¾‹é¢˜:**

**MT3479èµ‹å€¼**

[ç é¢˜é›†OJ-èµ‹å€¼ (matiji.net)](https://www.matiji.net/exam/brushquestion/358/3846/4C6668FEB8CFD6520DE73B365B31D1A4)

```c++
const int N = 300005;
const int MOD = 1e9+7;
//ä¸è¦æŠŠé¢˜ç›®æƒ³çš„å¤ªéš¾
int col[N];
int n,m,a,b;
vector<int> e[N];
int ksm(int x,int n){
    int ans = 1;
    while(n){
        if(n&1) ans = (ans*x)%MOD;
        x = (x*x)%MOD;
        n>>=1;
    }
    return ans;
}
bool dfs(int u,int c){
	col[u] = c;
	if(col[u] == 1) a++;b++;
	for(auto p: e[u]){
		if(!col[p]){
			if(dfs(p,3-c)) return true;
		}else{
			if(col[p]==c) return true;
		}
	}
	return false;
}
void solve(){
	cin >> n >> m;
	for(int i = 0; i < m;i++){
		int u,v;
		cin >> u >> v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
    int res = 1;
	for(int i = 1;i <= n;i++){ 
        if(!col[i]){
        	a = b = 0;
            if(dfs(i,1)){
                cout << 0 << endl;
                return;
            }
            res =(res*(ksm(2,a)+ksm(2,b-a))%MOD)%MOD;
        }
	}  
    cout << res << endl;

}
```

**æ—¶é—´å¤æ‚åº¦: O(n+m)**

#### 2.åŒˆç‰™åˆ©ç®—æ³•

![image-20240422135632639](img/image-20240422135632639.png)

åŒˆç‰™åˆ©ç®—æ³•å…¶å®å°±æ˜¯åœ¨æ±‚å¢å¹¿è·¯çš„ç®—æ³•

**ä»£ç **:

```c++
//dfsç‰ˆ
const int N = 1e5 + 7;
vector<int> e[N];
int match[N];
int vis[N];
//ç»™å®šä¸€ä¸ªäºŒåˆ†å›¾ï¼Œ
//å…¶å·¦éƒ¨ç‚¹çš„ä¸ªæ•°ä¸ºnï¼Œå³éƒ¨ç‚¹çš„ä¸ªæ•°ä¸ºmï¼Œè¾¹æ•°ä¸ºeï¼Œ
//æ±‚å…¶æœ€å¤§åŒ¹é…çš„è¾¹æ•°ã€‚
bool dfs(int u){
  for(auto p: e[u]){
    if(vis[p]) continue;
    vis[p] = 1;
    if(!match[p] || dfs(match[p])){
      match[p] = u;
      return 1;
    }
  }
  return 0;
}
void solve(){
  int n,m,e1;
  cin >> n >> m >> e1;
  for(int i = 0; i < e1;i++){
    int u,v;
    cin >> u >> v;
    e[u].push_back(v); //åªå»ºå•å‘è¾¹
  }
  int ans = 0;
  for(int i = 1; i <= n;i++){
    memset(vis,0,sizeof vis);
    if(dfs(i)) ans++;
  }
  cout << ans;
}
```

æ—¶é—´å¤æ‚åº¦O(n^3)

#### 3.KMç®—æ³•

### 7.åŸºç¯æ ‘



##### ä¾‹é¢˜

###### æ´›è°·P2607

[P2607 [ZJOI2008\] éª‘å£« - æ´›è°· | è®¡ç®—æœºç§‘å­¦æ•™è‚²æ–°ç”Ÿæ€ (luogu.com.cn)](https://www.luogu.com.cn/problem/P2607)

å†…å‘æ ‘,æ‰¾ä¸¤ä¸ªç¯ä¸ŠèŠ‚ç‚¹

```c++
const int P = 13331;
const int N = 1000005;
struct nodes
{
    int v,ne;
}e[N];
int h[N],idx = 0;
void add(int u,int v){
    e[idx] = {v,h[u]};
    h[u] = idx++;
}
int n;
int r1,r2;
int dp[N][2];
int vis[N];
void get_ring(int u,int rt){
    for(int i = h[u];~i;i=e[i].ne){
        int v = e[i].v;
        if(v==rt){
            r1 = v;
            r2 = u;
            return;
        }
        if(vis[v]) continue;
        vis[v] = 1;
        get_ring(v,rt);
    }
}
int a[N];
int dfs(int u,int rt){
    dp[u][0] = 0, dp[u][1] = a[u];
    for(int i = h[u];~i;i=e[i].ne){
        int v = e[i].v;
        if(v==rt) continue;
        dfs(v,rt);
        dp[u][0]+=max(dp[v][0],dp[v][1]);
        dp[u][1]+=dp[v][0];
    }
    return dp[u][0]; 
}
void solve(){
    memset(h,-1,sizeof h);
    cin >> n;
    for(int i = 1;i<=n;i++){
        int val,u;
        cin >> val >> u;
        add(u,i);
        a[i] = val;
    }
    int res = 0;
    for(int i = 1;i<=n;i++){
        if(vis[i]) continue;
        r1 = r2 = 0;
        get_ring(i,i);
        if(r1==0&&r2==0) continue;
        res+=max(dfs(r1,r1),dfs(r2,r2));
    }
    cout << res;
}
```



## <a name = "srp">å›› æ•°è®ºç¯‡</a>

### æ•°è®ºæ€§è´¨:

#### **1.åŒä½™æ€§**

**å¦‚æœx mod m == y mod m é‚£ä¹ˆ |x-y| = 0 mod m;ä¹Ÿå°±æ˜¯è¯´ å¦‚æœmæ˜¯x-yçš„ä¸€ä¸ªå› å­ é‚£ä¹ˆxå’Œyæ¨¡måŒä½™**

**å¦‚æœx==y é‚£ä¹ˆä¸€åˆ‡éƒ½åŒä½™**

### 1.è£´èœ€å®šç†(è´ç¥–å®šç†)

#### æ¦‚å¿µ

ä¸€å®šå­˜åœ¨**æ•´æ•°**x,y,æ»¡è¶³**ax+by = gcd(a,b)**

æ‰©å±•1:ä¸€å®šå­˜åœ¨**æ•´æ•°**x,y,æ»¡è¶³**ax+by = gcd(a,b)*n**

æ‰©å±•2:

![image-20240206193428835](img/image-20240206193428835.png)

![image-20240206193536938](img/image-20240206193536938.png)

#### ä»£ç :

```c++
int t = a[0];
for(int i = 1; i < n; i++){
    t = __gcd(t,a[i] < 0 ? -a[i]:a[i]); //a[i]ä»£è¡¨ç³»æ•°
} 
cout << t <<endl;
```

#### ä¾‹é¢˜:

æ´›è°·P4549

### 2.å¿«é€Ÿå¹‚

#### æ™®é€šå¿«é€Ÿå¹‚

![image-20240206195159773](img/image-20240206195159773.png)

##### ä»£ç 

```c++
int quickpow(int a,int n,int mod){
    int res = 1;
    while(n){
        if(n & 1) res = (res * a)%mod;
        a = (a * a)%mod;
        n >>= 1;
    }
    return res;
}
```

#### çŸ©é˜µå¿«é€Ÿå¹‚

##### çŸ©é˜µä¹˜æ³•

![image-20240206200248471](img/image-20240206200248471.png)

##### çŸ©é˜µå¿«é€Ÿå¹‚

![image-20240206205548511](img/image-20240206205548511.png)

###### ä»£ç 

```c++
int n,k;
const int mod = 1e9 + 7;
struct matrix
{
	int c[101][101];
	matrix(){memset(c,0,sizeof c);} //åˆå§‹åŒ–æ¯ä¸€ä¸ªçŸ©é˜µ
} A, res;
matrix operator*(matrix &x, matrix &y){ //é‡è½½ä¹˜æ³•,ä½¿å¾—çŸ©é˜µå¯ä»¥è¿›è¡Œä¹˜æ³•
	matrix t;//ä¸´æ—¶çŸ©é˜µ
	for(int i = 1; i <= n; i ++){
		for(int j = 1; j <= n; j++){
			for(int k = 1; k <= n; k++){
				t.c[i][j] = (t.c[i][j] + x.c[i][k]*y.c[k][j])%mod;		
			}
		}
	}
	return t;

}
void quickpow_martrix(int k){
	for(int i = 1; i <= n; i++) res.c[i][i] = 1; //åˆå§‹åŒ–resä¸ºå•ä½çŸ©é˜µç›¸å½“äºå¸¸æ•°1
												 //ä»»ä½•çŸ©é˜µä¹˜ä»¥å•ä½çŸ©é˜µéƒ½ç­‰äºæœ¬èº«
	while(k){
		if(k&1) res = res * A;
		A = A*A;
		k >>= 1;
	}

}
```

###### ä¾‹é¢˜

æ´›è°·P3390

### 3.åŒä½™å¼ ä¹˜æ³•é€†å…ƒ è´¹é©¬å°å®šç†

![image-20240214184023833](img/image-20240214184023833.png)

![image-20240214184522825](img/image-20240214184522825.png)

### 4.ä¸å®šæ–¹ç¨‹ æ‰©å±•æ¬§å‡ å¾·é‡Œ

![image-20240214185925489](img/image-20240214185925489.png)

![image-20240214190332101](img/image-20240214190332101.png)

![image-20240214190525617](img/image-20240214190525617.png)

### 5.æ•´é™¤åˆ†å—

![image-20240303184838272](img/image-20240303184838272.png)

**æ•´é™¤åˆ†å—ä»£ç çš„æ¨¡æ¿**:

```c++
//æ•´é™¤åˆ†å—
for(int l=1,r;l<=n;l=r+1)
{
    r=n/(n/l);//åè¾¹(n/l)ä¸€å®šè¦åŠ æ‹¬å·ï¼Œæ˜¯å…ˆå‘ä¸‹å–æ•´åå†è¢«né™¤
    //æ‰§è¡Œä¸€äº›æ“ä½œ
}
```

ä¾‹é¢˜ :

18th ZCPC

**F - Fair Distribution**

```c++
void solve(){
	int n,m;
	cin >> n >> m;
	if(m<n){
		cout << n - m << endl;
		return;
	}
	if(m==n) cout << 0 << endl;
	else{
		int ans = 0x3f3f3f3f;
		for(int l = 1,r; l <= n; l=r+1){
			r = (m-1)/((m-1)/l);
			int us = ((m+l-1)/l * l - m + n - l);
			ans = min(us,ans); 
		}
		cout << ans << endl;
	}
	

}
```

![image-20240304151132441](img/image-20240304151132441.png)

### 6.æ±‚é€†å…ƒ

##### 1.çº¿æ€§é€’æ¨

```c++
inv[1] = 1;
for(int i = 2; i <= n; ++i) inv[i] = inv[mod % i] * (mod - mod / i) % mod;
```

##### **2.è´¹é©¬å°å®šç†**

```c++
int ksm(int x,int n,int mod){
	int res = 1;
    while(n){
        if(n&1) res = res * x % mod;
        x = x * x%mod;
        n >>= 1;
    }
    return res;
}
int iv(int x){
    return ksm(x,mod - 2,mod);
}
```

##### 3.çº¿æ€§æ±‚ç»„åˆæ•°

```c++
int fac[N],inv[N];
int ksm(int x,int n,int mod){
	int res = 1;
    while(n){
        if(n&1) res = res * x % mod;
        x = x * x%mod;
        n >>= 1;
    }
    return res;
}
int iv(int x){
    return ksm(x,mod - 2,mod);
}
void getfac(){
    fac[0] = inv[0] = 1;
    for(int i = 1; i<N;i++){
        fac[i]=fac[i-1]*i%mod;
         inv[i] = iv(i) * inv[i-1] %mod;
    }
}
int C(int n,int m){
    return fac[n]*inv[n-m]%mod*inv[m]%mod;
}


```



## <a name = "sjjgp">äº” æ•°æ®ç»“æ„ç¯‡</a>

### 1.å¹¶æŸ¥é›†

#### æ¨¡ç‰ˆ

```c++
struct DSU {
    vector<int> f, siz;
    DSU() {}
    DSU(int n) {
        init(n);
    }
    
    void init(int n) {
        f.resize(n);
        iota(f.begin(), f.end(), 0);
        siz.assign(n, 1);
    }
    
    int find(int x) {
        while (x != f[x]) {
            x = f[x] = f[f[x]];
        }
        return x;
    }
    
    bool same(int x, int y) {
        return find(x) == find(y);
    }
    
    bool merge(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) {
            return false;
        }
        siz[x] += siz[y];
        f[y] = x;
        return true;
    }
    
    int size(int x) {
        return siz[find(x)];
    }
};
```



##### ä¼˜åŒ–å‰

```cpp
//å¹¶æŸ¥é›†çš„ç»“æ„å®šä¹‰ 
#define N 50001;
int u[N];
//åˆå§‹åŒ–
void init(){
	for(int i = 0; i < N; i++) u[i] = -1; 
} 
//å¯»æ‰¾å…ƒç´ xçš„æ•°dæ ¹
int findu(int x){
	while(u[x]>=0){
		x = u[x]; 
	} 
	return x; 
}
//åˆå¹¶(union) ä¸¤ä¸ªæ ¹ root2 åˆå¹¶åˆ°root1 
void unionu(int root1,int root2){
	if(root1 == root2) return;
	u[root2] = root1; 
} 
```

##### ä¼˜åŒ–å

```c++
//åˆå§‹åŒ–
void init(){
	for(int i = 0; i < N; i++) u[i] = -1; 
} 
//æŸ¥æ‰¾åˆ°ä¸€æ¬¡å°±æŒ‚åœ¨æ ¹èŠ‚ç‚¹ä¸‹é¢ä»è€Œä¼˜åŒ– 
int findu(int x){
	int root = x;
	while(u[root]>=0){
		root = u[root]; 
	} //å¾ªç¯æ‰¾æ ¹
	while(x!=root){
		int t = u[x]; //tæŒ‡å‘xçš„çˆ¶èŠ‚ç‚¹
		u[x] = root;//å°†xç›´æ¥æŒ‚åœ¨æ ¹èŠ‚ç‚¹ä¸‹é¢
		x = t; 
	} 
	return root; 
}
//åˆå¹¶(union) ä¸¤ä¸ªæ ¹ root2 åˆå¹¶åˆ°root1 
void unionu(int root1,int root2){
	if(root1 == root2) return;
	if(u[root2] > u[root1]){ //root2èŠ‚ç‚¹æ•°æ›´å°‘ 
		u[root1] += u[root2];
		u[root2] = root1;//å°æ•°åˆå¹¶åˆ°å¤§æ ‘ 
	} else{
		u[root2] += u[root1];
		u[root1] = root2; 
	} 
} 
```

##### åˆå¹¶ä¸¤ä¸ªä»»æ„èŠ‚ç‚¹

```c++
void unionu(int node1,int node2){
	int root1 = findu(node1);
	int root2 = findu(node2);
	if(root1 == root2) return;
	if(u[root2] > u[root1]){ //root2èŠ‚ç‚¹æ•°æ›´å°‘ 
		u[root1] += u[root2];
		u[root2] = root1;//å°æ•°åˆå¹¶åˆ°å¤§æ ‘ 
	} else{
		u[root2] += u[root1];
		u[root1] = root2; 
	} 
} 
```





### 2.STè¡¨

#### ç”¨é€”

![image-20240205211401198](img/image-20240205211401198.png)

#### é¢„å¤„ç†

![image-20240205211525168](img/image-20240205211525168.png)

#### æŸ¥è¯¢

![image-20240205211634035](img/image-20240205211634035.png)

#### ä»£ç 

```c++
const int N = 100005;
int st[N][21];
int n;
int a[N];
void get_st(){
	for(int i = 1; i <= n; i++) st[i][0] = a[i]; //åˆå§‹åŒ–,ä¹Ÿå¯ç›´æ¥è¾“å…¥
	//æšä¸¾åŒºé—´é•¿åº¦ 2^jæ¬¡
	//iæ˜¯ç¬¬iä¸ªæ•°ä¸ºèµ·ç‚¹
	for(int j = 1; j <= 20; j++){
		for(int i = 1; i + (1 << j) - 1 <= n; i++){
			st[i][j] = max(st[i][j - 1],st[i + (1 << (j - 1))][j - 1]);
		}
	}
}
int quary(int l,int r){
	int len = log2(r-l+1);
	return max(st[l][len],st[r - (1 << len) + 1][len]); //æ³¨æ„è¦åŠ 1;
}
void solve(){
	int q;
	cin >> n >> q;
	for(int i = 1; i <= n;i++){
		cin >> a[i];
	}
	get_st();
	while(q--){
		int l,r;
		cin >> l >> r;
		int res = quary(l,r);
		cout << res << endl;
	}
}
```

### 3.01Trie

#### ä¾‹é¢˜

**CF1847C**

æ±‚æŸæ®µåŒºé—´çš„å¼‚æˆ–æœ€å¤§å€¼

```c++
int ch[N][2];
int idx;
void add(int x){
	int p = 0;
	for(int i = 8; i >= 0; i--){
		int u = x >> i & 1;
		if(!ch[p][u]) ch[p][u] = ++idx;
		p = ch[p][u];
	}
}
int query(int x){
	int res = 0, p = 0;
	for(int i = 8; i >= 0;i--){
		int u = x >> i & 1;
		if(ch[p][u ^ 1]){
			res |= 1 << i;
			p = ch[p][u ^ 1];
		}else if(ch[p][u]){
			p = ch[p][u];
		}
	}
	return res;
}
void solve(){
	int n;
	memset(ch,0,sizeof ch);
	idx = 0;
	cin >> n;
	int pre = 0;
	add(0);
	int ans = 0;
	for(int i = 1; i <= n; i++){
		int t;
		cin >> t;
		pre = pre ^ t;
		ans = max(ans,query(pre));
		add(pre);
	}
	cout << ans << endl;
	

}
signed main(){
	std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    std::cout.tie(0);
	int times = 1;
	cin >> times;
	while(times--){
		solve();
	}
	return 0;
}
```

**BD201404 XOR SUM**

```c++
int ch[N*2][2];
int as[N*2];
int idx = 0;
void add(int x){
	int p = 0;
	for(int i = 31; i >= 0; i--){
		int u = (x >> i) & 1;
		if(!ch[p][u]) ch[p][u] = ++idx;
		p = ch[p][u];
	}
	as[p] = x;
}
int query(int x){
	int res = 0, p = 0;
	for(int i = 31; i >= 0;i--){
		int u = (x >> i) & 1;
		if(ch[p][u ^ 1]){
			res |= (u^1) << i;
			p = ch[p][u ^ 1];
		}else if(ch[p][u]){
            res |= (u) << i;
			p = ch[p][u];
		}
	}
	return res;
}
void solve(){
	for(int i = 0; i < N*2;i++){
		for(int j = 0; j < 2;j++){
			ch[i][j] = 0;
		}
	}
	idx = 0 ;
    memset(as,0,sizeof as);
	int n,m;
	//add(0);
	cin >> n >> m;
	for(int i = 0; i < n;i++){
		int t;
		cin >> t;
		add(t);
	}
	while(m--){
		int t;
		cin >> t;
		cout << query(t) << endl;;
	}
}
```



### 4.çº¿æ®µæ ‘

è€æ˜¯çŠ¯é”™,è®°å¾—å­æ ‘tagæ˜¯ç´¯åŠ çˆ¶äº²çš„tagçš„è€Œä¸æ˜¯ç›´æ¥=çˆ¶äº²tag

##### æŠ€å·§:

**åŒºé—´åŠ ä¹˜(ä¹˜æ³•ä¼˜å…ˆåŸåˆ™):**

è®¾çˆ¶èŠ‚ç‚¹çš„æ ‡è®°ä¸ºmå’Œa  å­èŠ‚ç‚¹æ ‡è®°ä¸ºmul å’Œ add;

mul = mul * m;

add = add*m+a

```c++
int n,p;
int a[N];
struct Tree{
	int l,r,mul,add,val;
} tr[N<<2];
void up(int u){
	tr[u].val = (tr[lc].val + tr[rc].val)%p;
}
void build(int u,int l,int r){
	tr[u] = {l,r,1,0,0};
	if(l==r){
		tr[u].val = a[l];
		return;
	}
	int mid = (l + r) >> 1;
	build(lc,l,mid);
	build(rc,mid + 1,r);
	up(u);
}
void calc(int u,int m,int a){
	tr[u].val = (tr[u].val * m + (tr[u].r - tr[u].l + 1) * a)%p;
	tr[u].mul = (tr[u].mul * m)%p;
	tr[u].add = (tr[u].add*m + a)%p;
}
void down(int u){
	calc(lc,tr[u].mul,tr[u].add);
	calc(rc,tr[u].mul,tr[u].add);
	tr[u].add = 0;
	tr[u].mul = 1;
}
void update(int u,int l,int r,int m,int a){
	if(tr[u].r < l || tr[u].l > r) return;
	if(tr[u].l >= l && tr[u].r <= r){
		calc(u,m,a);
		return;
	}
	down(u);
	update(lc,l,r,m,a);
	update(rc,l,r,m,a);
	up(u);
}
int quary(int u,int l,int r){
	if(tr[u].r < l || tr[u].l > r) return 0;
	if(tr[u].l >= l && tr[u].r <= r){
		return tr[u].val;
	}
	down(u);
	return (quary(lc,l,r) + quary(rc,l,r))%p;
}
void solve(){
	cin >> n >> p;
	for(int i = 1; i <= n;i++) cin >> a[i];
	int q;
	cin >> q;
	build(1,1,n);
	while(q--){
		int mod,l,r;
		cin >> mod >> l >> r;
		if(mod == 1){
			int val;
			cin >> val;
			update(1,l,r,val,0);
		}else if(mod == 2){
			int val;
			cin >> val;
			update(1,l,r,1,val);
		}else{
			cout << quary(1,l,r) << endl;
		}
	}
}
```



##### ä»£ç :

```c++
#define lc p<<1
#define rc p<<1|1
int n,w[N];
struct node{
	int l,r,sum,lz;
}tr[N*4]; //è‡³å°‘*4é˜²æ­¢è¶Šç•Œ

void pushup(int p){
	tr[p].sum = tr[lc].sum + tr[rc].sum;
}
void pushdown(int p){
	if(tr[p].lz){ //å¦‚æœæœ‰lazyæ ‡è®°åˆ™å‘ä¸‹ä¼ é€’
		tr[lc].sum += tr[p].lz*(tr[lc].r - tr[lc].l + 1);//å€¼ä¹˜ä»¥é•¿åº¦
		tr[rc].sum += tr[p].lz*(tr[rc].r - tr[rc].l + 1);//åŒç†
		tr[lc].lz+=tr[p].lz; //ä¼ é€’lazyæ ‡è®°
		tr[rc].lz+=tr[p].lz;
		tr[p].lz = 0; //æ¸…ç©º	
	}
}
void build(int p,int l, int r){
	tr[p] = {l,r,w[l],0};
	if(l==r) return; //æ˜¯å¶å­å°±è¿”å›
	int m = l+r>>1;
	build(lc,l,m);
	build(rc,m+1,r);
	pushup(p);//æ›´æ–°å®Œä¸‹é¢èŠ‚ç‚¹,è¿”ä¸Šæ¥ä¼ å€¼
}
//å°†ä¸€æ®µåŒºé—´éƒ½æ“ä½œä¸€ä¸ªæ•°
void update(int p,int x,int y,int k){
	//p:çˆ¶èŠ‚ç‚¹,xå·¦åŒºé—´,yå³åŒºé—´,kå€¼
	if(x<=tr[p].l&&tr[p].r <= y){ //åŒºé—´è¦†ç›–
		tr[p].sum+=(tr[p].r-tr[p].l+1)*k;
		tr[p].lz+=k;//å…ˆlz åpushdown;
		return;
	} 
	//æœªå®Œå…¨è¦†ç›–
	int m = tr[p].l+tr[p].r>> 1;
	pushdown(p);//å‘ä¸‹ä¼ é€’
	if(x<=m) update(lc,x,y,k);
	if(y>m) update(rc,x,y,k);
	pushup(p);//å‘ä¸Šä¼ é€’
}
int query(int p,int x,int y){
	if(x <= tr[p].l&&tr[p].r <= y){//è¦†ç›–åˆ™è¿”å›
		return tr[p].sum;
	}
	int m = tr[p].l+tr[p].r>> 1;
	pushdown(p); //å‘ä¸‹ä¼ é€’
	int sum = 0;
	if(x<=m) sum+=query(lc,x,y);
	if(y>m) sum+=query(rc,x,y);
	return sum;
}
void solve(){
	int n,m;
	cin >> n >> m;
	for(int i = 1; i <= n ; i++){
		cin >> w[i]; //è¾“å…¥ä¸€ä¸ªåŒºé—´
	}
	build(1,1,n);
	while(m--){
		int mod;
		cin >> mod;
		if(mod == 1){
			int x,y,k;
			cin >> x >> y >> k; //æ›´æ–° [x,y] æ•´ä½“+k
			update(1,x,y,k);
		}else{
			int x,y;
			cin >> x >> y;
			cout << query(1,x,y) << endl; //è¾“å‡º
		}
	}
}
```

##### luogu P4588

```c++
#define lc u<<1
#define rc u<<1|1
const int N = 100005;
struct Tree{
	int l,r; //åŒºé—´å·¦å’ŒåŒºé—´å³
	int mul; //åŒºé—´ç§¯
}tr[N*4];
int m;
void pushup(int u){
	tr[u].mul = (tr[lc].mul * tr[rc].mul)%m;
}
void build(int u,int l,int r){
	tr[u]={l,r,1};//å¯¹äºè¯¥é¢˜æ¯ä¸ªèŠ‚ç‚¹åˆå§‹åŒ–ä¸º1
	if(l==r) return; //å¶å­è¿”å›
	int mid = (l + r) >> 1;
	build(lc,l,mid);
	build(rc,mid+1,r);
	pushup(u);
}
//å•ç‚¹ä¿®æ”¹
void change(int u,int x,int c){
	if(x==tr[u].l && x== tr[u].r){
		tr[u].mul = c;
		return;
	}
	int mid = (tr[u].l + tr[u].r) >> 1;
	if(x<=mid) change(lc,x,c);
	if(x>mid) change(rc,x,c);
	pushup(u);
}
```

##### CF242E

```c++
#define lc u<<1
#define rc u<<1|1
const int N = 100005;
int n;
int a[N];
struct Tree{
	int l,r,tag;
	int val[22];
}tr[N << 2];
void push_up(int u){
	for(int i = 0; i < 20;i++){
		tr[u].val[i] = tr[lc].val[i] + tr[rc].val[i];
	}
}
void build(int u,int l,int r){
	tr[u].l = l;
	tr[u].r = r;
	tr[u].tag = 0;
	if(l ==r){
		for(int i = 0; i < 20;i++){
			if((a[tr[u].l] >> i) & 1) tr[u].val[i] = 1;
			else tr[u].val[i] = 0;
		}
		return;
	}
	int mid = (l + r) >> 1;
	build(lc,l,mid);
	build(rc,mid + 1,r);
	push_up(u);
}
void down(int u){
	for(int i = 0; i < 20;i++){
		if((tr[u].tag >> i) & 1){
			tr[lc].val[i] = (tr[lc].r - tr[lc].l + 1) - tr[lc].val[i];
			tr[rc].val[i] = (tr[rc].r - tr[rc].l + 1) - tr[rc].val[i];
		}  
	}
	tr[lc].tag ^= tr[u].tag;
	tr[rc].tag ^= tr[u].tag;
	tr[u].tag = 0;
}
void update(int u,int l,int r,int val){
	if(tr[u].r < l || tr[u].l > r) return;
	if(tr[u].l >= l && tr[u].r <= r){
		for(int i =0; i < 20;i++){
			if((val >> i)&1) tr[u].val[i] = (tr[u].r - tr[u].l + 1) - tr[u].val[i];
		}
		tr[u].tag ^= val;
		return; 
	}
	down(u);
	update(lc,l,r,val);
	update(rc,l,r,val);
	push_up(u);
}
int quary(int u,int l,int r){
	if(tr[u].l > r || tr[u].r < l) return 0;
	if(tr[u].r <= r && tr[u].l >= l){
		int res = 0;
		int p = 1;
		for(int i = 0 ;i < 20;i++){
			res+=pow(2,i)*tr[u].val[i];
		}
		return res;
	}
	down(u);
	return quary(lc,l,r) + quary(rc,l,r);
}
void solve(){
	cin >> n;
	for(int i = 1; i <= n;i++) cin >> a[i]; 
	int q;
	cin >> q;
	for(int i = 0; i < N;i++) memset(tr[i].val,0,sizeof tr[i].val);
	build(1,1,n);
	
	while(q--){
		int op,l,r;
		cin >> op >> l >> r;
		if(op == 1){
			cout << quary(1,l,r) <<endl;
		}else{
			int x;
			cin >> x;
			update(1,l,r,x);
		}
	}
}
```

##### **CF460C**

###### äºŒåˆ†+çº¿æ®µæ ‘

```c++
#define lc u<<1
#define rc u<<1|1
const int N = 100005;
struct Tree{
	int val,l,r,tag;
}tr[N<<2];
void up(int u){
	tr[u].val = tr[lc].val + tr[rc].val;
}
void build(int u,int l,int r){
	tr[u] = {0,l,r,0};
	if(l==r) return;
	int mid = (l+r )>> 1;
	build(lc,l,mid);
	build(rc,mid+1,r);
}
void down(int u){
	tr[lc].tag += tr[u].tag;
	tr[rc].tag += tr[u].tag;
	tr[lc].val += (tr[lc].r - tr[lc].l +1) * tr[u].tag;
	tr[rc].val += (tr[rc].r - tr[rc].l +1) * tr[u].tag;
	tr[u].tag = 0;
}
void update(int u,int l,int r,int val){
	if(tr[u].l >r || tr[u].r < l) return;
	if(tr[u].l >= l && tr[u].r <= r){
		tr[u].val += (tr[u].r - tr[u].l + 1) * val;
		tr[u].tag += val;
		return;
	}
	down(u);
	update(lc,l,r,val);
	update(rc,l,r,val);
	up(u);
}
//æŸ¥è¯¢xç‚¹åŠ è¿‡å‡ æ¬¡
int quary(int u,int x){
	if(tr[u].l > x || tr[u].r < x) return -1;
	if(tr[u].l==x && tr[u].r==x){
		return tr[u].val;
	}
	down(u);
	int k = quary(lc,x);
	if(k != -1) return k;
	return quary(rc,x);
}
int n,m,w;
int a[N];
bool check(int x){
	build(1,1,n);
	int cnt = 0;
	for(int i = 1; i <= n;i++){
		if(a[i] >= x) continue;
		int ad = quary(1,i);
		//debug(ad);
		if(a[i] + ad >= x) continue;
		int c = x - (a[i] + ad);
		update(1,i,i+w - 1,c);
		cnt+=c;
		if(cnt > m) return false;
	}
	return true;
}
void solve(){
	cin >> n >> m >> w;
	//build(1,1,n);
	for(int i = 1; i <= n;i++) cin >> a[i];
	int l = 0, r = 1e13,ans = 0;
	while(l <= r){
		int mid = (l + r) >> 1;
		if(check(mid)){
			l = mid + 1;
			ans = mid;
		}else{
			r = mid - 1;
		}
	}
	cout << ans;
}
```

##### luoguP1471

```
//ç»´æŠ¤å¹³å‡å€¼,æ–¹å·®ç­‰äº æ‰€æœ‰å¹³æ–¹å’Œ +(å¹³å‡æ•°^2 *åŒºé—´é•¿åº¦) - (sum)*å¹³å‡æ•°*2
//1+25+16+4+9 = (55 + 45 - 90) * 1/5;
//æˆ‘ä»¬åªè¦æ±‚åŒºé—´å’Œå³å¯
//è¿˜è¦æ±‚å¹³æ–¹å’Œ
//su(pf) = su(pf) + 2*sum * k + k^2*(åŒºé—´é•¿)
int n;
double a[N];
struct Tree{
	int l,r;
	double add,val,pf;
} tr[N<<2];
void calc(int u,double val){
	tr[u].pf += 2.0*tr[u].val*val + val*val*(tr[u].r - tr[u].l + 1);
	tr[u].val += (val) * (tr[u].r - tr[u].l + 1);	
}
void up(int u){
	tr[u].val = tr[lc].val+tr[rc].val;
	tr[u].pf = tr[lc].pf + tr[rc].pf;
}
void build(int u,int l,int r){
	tr[u] = {l,r,0.00,0.00,0.00};
	if(l==r){
		calc(u,a[l]);
		return;
	}
	int mid = (l + r) >> 1;
	build(lc,l,mid);
	build(rc,mid+1,r);
	up(u);
}
void down(int u){
	calc(lc,tr[u].add);
	calc(rc,tr[u].add);
	tr[lc].add += tr[u].add;
	tr[rc].add += tr[u].add;
	tr[u].add = 0;
}
void update(int u,int l,int r,double val){
	if(tr[u].l > r || tr[u].r < l) return;
	if(tr[u].l >= l && tr[u].r <= r){
		calc(u,val);
		tr[u].add += val;
		return;
	}
	down(u);
	update(lc,l,r,val);
	update(rc,l,r,val);
	up(u);
}
pair<double,double> quary(int u,int l,int r){
	if(tr[u].l > r || tr[u].r < l) return {0.00,0.00};
	if(tr[u].l >= l && tr[u].r <= r){
		return {tr[u].val,tr[u].pf};
	}
	down(u);
	auto p1 = quary(lc,l,r);
	auto p2 = quary(rc,l,r);
	return {p1.first+p2.first,p1.second+p2.second};
}	

void solve(){
	cin >> n;
	int q;
	cin >> q;
	for(int i = 1; i <= n;i++) cin >> a[i];
	build(1,1,n);
	while(q--){
		int op,l,r;
		cin >>op>>l>>r;
		if(op==1){
			double val;
			cin >> val;
			update(1,l,r,val);
		}else if(op==2){
			double t = quary(1,l,r).first/(r-l+1);
			printf("%.4lf\n",t);
		}else{
			auto p = quary(1,l,r);
			double pf = p.second;
			double su = p.first;
			double pj = su*1.0/(r-l+1);
			double res = (pf + (pj * pj * (r-l + 1)) - (su*pj*2))/(r-l+1);
			printf("%.4lf\n",res);
		}
	}
	

}
```



### 5.æ ‘çŠ¶æ•°ç»„ + ç¦»æ•£åŒ–

#### ç¦»æ•£åŒ–

ç¦»çº¿,åœ¨çº¿æ¦‚å¿µ:

ç¦»çº¿->å…ˆå­˜æ“ä½œ(è¯¢é—®),åé¢å†æ‰§è¡Œ;

åœ¨çº¿->ä¸€æ¬¡è¯¢é—®,ä¸€æ¬¡å®Œæˆ;

**ç”¨æ³•,æ¦‚å¿µ:**å¦‚æœæ•°çš„èŒƒå›´å¾ˆå¤§æ¯”å¦‚è¯´1e9æ•°ç»„è£…ä¸ä¸‹,ä½†æ˜¯è¯¢é—®å’Œæ“ä½œçš„å®é™…æ•°å¾ˆå°æ¯”å¦‚è¯´è¯¢é—®+æ“ä½œåŠ èµ·æ¥å®é™…ä¸Šæ“ä½œçš„æ•° < 1e7å¤§æ¦‚,å°±å¯ä»¥ç¦»æ•£åŒ–,å°†ç©ºé—´(æ’åºå»é‡)æ•´åˆåˆ°ä¸€ä¸ªlsæ•°ç»„,ç„¶åé€šè¿‡äºŒåˆ†,æ‰¾åˆ°åŸæ¥å¤§ä¸‹æ ‡çš„æ˜ å°„å€¼->å°ä¸‹æ ‡,ç„¶åå¼€ä¸ªæ•°ç»„,å°†è¿™ä¸ªæ•°ç»„ä½œä¸ºæ˜ å°„æ•°ç»„,æ¯ä¸ªå¤§ä¸‹æ ‡é€šè¿‡LSçš„äºŒåˆ†æ‰¾åˆ°æ–°æ•°ç»„å¯¹åº”çš„æ˜ å°„å€¼,ç„¶ååœ¨æ–°æ•°ç»„è¿›è¡Œæ–°çš„æ“ä½œ

**ä¾‹é¢˜:**

[æˆ‘çš„å¾ˆé•¿ï¼Œä½ ç®—ä¸€ä¸‹ - StarryCoding | è¸å‡ºç¼–ç¨‹ç¬¬ä¸€æ­¥](https://www.starrycoding.com/problem/63)

```c++
const int N = 300005;
//ä¸è¦æŠŠé¢˜ç›®æƒ³çš„å¤ªéš¾
vector<int> LS;//ç¦»æ•£åŒ–
vector<pair<int,int>> add(N);//ä¿®æ”¹	
vector<pair<int,int>> qs(N);//è¯¢é—®
int a[N],pre[N];//æ¯ä¸€ä¸ªçš„å€¼
int getidx(int x){
	//[1,ls.size()];
	return lower_bound(LS.begin(),LS.end(),x) - LS.begin() + 1;
}
void solve(){
	int n,q;
	cin >> n >> q;

	for(int i = 1; i <= n; i++){
		int t,v;
		cin >> t >> v; //å•ç‚¹ä¿®æ”¹ a[t] += v
		add[i] = {t,v};
		LS.push_back(t);
	}
	for(int i = 1; i <= q;i++){
		int x,y;
		cin >> x >> y;
		qs[i] = {x,y};
		LS.push_back(x);
		LS.push_back(y);
	}
	//æ’åºå»é‡
	sort(LS.begin(),LS.end());
	LS.erase(unique(LS.begin(),LS.end()),LS.end());
	for(int i = 1; i <= n;i++){
		int idx,w;
		idx = getidx(add[i].first);
		w = add[i].second;
		a[idx] += w;
	}
	for(int i = 1; i <= LS.size();i++){ //æ³¨æ„è¿™é‡Œæ˜¯LS.size();
		pre[i] = pre[i - 1] + a[i];
	}
	for(int i = 1; i <= q;i++){
		int l = getidx(qs[i].first), r = getidx(qs[i].second);
		cout << pre[r] - pre[l - 1] << endl;
	}
}
```

#### **æ ‘çŠ¶æ•°ç»„**

**æŠ€å·§**

ç¢°åˆ°ä¸å¸¦ä¿®æ”¹çš„è¯¢é—®,**æ ‘çŠ¶æ•°ç»„åŠ ç¦»çº¿**å¯èƒ½ä¼šå·§å¦™è§£å†³

**æ¦‚å¿µç†è§£:**

å¯¹äº**æ™®é€šæ•°ç»„**è€Œè¨€ï¼Œ**å•ç‚¹ä¿®æ”¹**çš„[æ—¶é—´å¤æ‚åº¦](https://so.csdn.net/so/search?q=æ—¶é—´å¤æ‚åº¦&spm=1001.2101.3001.7020)æ˜¯**O(1)**ï¼Œä½†**åŒºé—´æ±‚å’Œ**çš„å¤æ‚åº¦æ˜¯**O(n)**
å¯¹äº**å‰ç¼€å’Œ**è€Œè¨€ï¼Œ**åŒºé—´æ±‚å’Œ**çš„å¤æ‚åº¦æ˜¯**O(1)**ï¼Œä½†**å•ç‚¹ä¿®æ”¹**çš„æ—¶é—´å¤æ‚åº¦æ˜¯**O(n)**

è€Œæ ‘çŠ¶æ•°ç»„æ˜¯æŠ˜ä¸­,å¯ä»¥å°†å•ç‚¹ä¿®æ”¹å’ŒåŒºé—´æŸ¥è¯¢éƒ½æ§åˆ¶ä½**O(logn)**ä¸­

ä»–çš„æ ¸å¿ƒæ˜¯lowbit,é€šè¿‡lowbitå®ç°logçº§åˆ«çš„æŸ¥è¯¢ä¸å•ç‚¹ä¿®æ”¹

**æ ‘çŠ¶æ•°ç»„åº”è¯¥é•¿ä»¥ä¸‹æ ·å­(ç»¿):**

![image-20240218153913261](img/image-20240218153913261.png)

##### å•ç‚¹ä¿®æ”¹

**ä¾‹é¢˜**

[ã€æ¨¡æ¿ã€‘æ ‘çŠ¶æ•°ç»„ï¼ˆå•ç‚¹ä¿®æ”¹ï¼‰ - StarryCoding | è¸å‡ºç¼–ç¨‹ç¬¬ä¸€æ­¥](https://www.starrycoding.com/problem/40)

å•ç‚¹+å€¼

```c++
const int N = 200005;
//ä¸è¦æŠŠé¢˜ç›®æƒ³çš„å¤ªéš¾
int a[N], t[N];
int n,q;
//lowbit
int lb(int x){return x&-x;}
void update(int k,int x){
	for(int i = k; i <= n; i+=lb(i)) t[i]+=x; //æ³¨æ„æ˜¯lb(i)
}
int quary(int k){
	int res =0 ;
	for(int i = k; i > 0; i -= lb(i)) res+=t[i];
	return res;
}
void solve(){
	
	cin >> n >> q;
	for(int i = 1; i <= n; i++) cin >> a[i];
	for(int i = 1; i <= n ; i++){
		update(i,a[i]);
	}
	while(q--){
		int op;
		cin >> op;
		if(op==1){
			int k,v; cin >> k >> v;
			update(k,v);
		}else{
			int l,r; cin >> l >> r;
			cout << quary(r) - quary(l - 1) << endl;
		}
	}
}
```

##### åŒºé—´ä¿®æ”¹

(å•ç‚¹ä¿®æ”¹ä¹Ÿå¯ç”¨åŒºé—´ä¿®æ”¹çš„æ¿å­,æŠŠç‚¹l,rçœ‹æˆk,k+1å³å¯)

å•ç‚¹ä¿®æ”¹

```
//æ¯”å¦‚è¯´ä¿®æ”¹k->k+v
update(k,v);
update(k+1,-v);
```

å•ç‚¹æŸ¥è¯¢

```
//æ¯”å¦‚è¯´æŸ¥k
//quary(k) - quary(k - 1)å³å¯
```

**ä¾‹é¢˜:**

[æ ‘çŠ¶æ•°ç»„ï¼ˆåŒºé—´ä¿®æ”¹ï¼‰ - StarryCoding | è¸å‡ºç¼–ç¨‹ç¬¬ä¸€æ­¥](https://www.starrycoding.com/problem/41)

```c++
const int N = 200005;
//ä¸è¦æŠŠé¢˜ç›®æƒ³çš„å¤ªéš¾
int a[N], td[N], tdi[N];
int n,q;
//lowbit
int lb(int x){return x&-x;}
void update(int k,int x){
	for(int i = k; i <= n; i+=lb(i)) td[i]+=x, tdi[i] += k * x;
}
int quary(int k){
	int res =0 ;
	for(int i = k; i > 0; i -= lb(i)) res+= (k+1)*td[i] - tdi[i];
	return res;
}
void solve(){
	
	cin >> n >> q;
	for(int i = 1; i <= n; i++) cin >> a[i];
	for(int i = 1; i <= n ; i++){
		update(i,a[i]);
		update(i+1,-a[i]);
	}
	while(q--){
		int op;
		cin >> op;
		if(op==1){
			int l,r,v; cin >> l >> r >> v;
			update(l,v);
			update(r+1,-v);
		}else{
			int l,r; cin >> l >> r;
			cout << quary(r) - quary(l - 1) << endl;
		}
	}
}
```

##### æŠ€å·§

æˆ‘ä»¬å¯¹A*,*B*æ•°ç»„éƒ½ç»è¿‡è¿™æ ·ç¦»æ•£åŒ–åï¼Œè®¾ç¦»æ•£åŒ–åçš„æ•°ç»„ä¸ºa*,*b*ï¼Œæ–°å»ºä¸€ä¸ªæ•°ç»„ğ‘™å¹¶ä»¤ğ‘™[ğ‘[ğ‘–]]=ğ‘[ğ‘–]è¿™æ ·æ“ä½œåæˆ‘ä»¬ä¼šå‘ç°ğ‘™[ğ‘–]è¡¨ç¤ºçš„æ˜¯ğ´*ä¸­i*è¿™ä¸ªä½ç½®çš„æ•°åœ¨Bä¸­çš„ä½ç½®ã€‚

##### ä¾‹é¢˜

###### **1.æ±‚é€†åºå¯¹ä¸ªæ•°**

[æ±‚é€†åºå¯¹ä¸ªæ•° - StarryCoding | è¸å‡ºç¼–ç¨‹ç¬¬ä¸€æ­¥](https://www.starrycoding.com/problem/31)

```c++
int n;
int a[N],t[N];
vector<int> LS;
int getidx(int x){
	return lower_bound(LS.begin(),LS.end(),x) - LS.begin() + 1;
}
int lb(int x){return x&-x;};
void update(int k,int v){
	for(int i = k; i <= LS.size(); i+=lb(i)){
		t[i]+=v;
	}
}
ll quary(int k){
	int res = 0;
	for(int i = k; i > 0; i-=lb(i)){
		res += t[i];
	}
	return res;
}

void solve(){
	cin >> n;
	for(int i = 1; i <= n; i++) {
		cin >> a[i];
		LS.push_back(a[i]);
	}
	sort(LS.begin(),LS.end());
	LS.erase(unique(LS.begin(),LS.end()), LS.end());
	ll cnt = 0;
	for(int i = 1; i <= n; i++){
		cnt += quary(LS.size()) - quary(getidx(a[i]));
		update(getidx(a[i]),1);
	}
	cout <<cnt <<endl;

}

```

###### 2.LIS

[300. æœ€é•¿é€’å¢å­åºåˆ— - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/longest-increasing-subsequence/)

```c++
class Solution {
public:
    static const int N = 1e4;
    vector<int> LS;
    int t[N]; //aä½œä¸ºç¦»æ•£åŒ–åçš„æ•°ç»„
    int getidx(int x){
        return lower_bound(LS.begin(),LS.end(),x) - LS.begin() + 1; 
    }
    int lb(int x){return x&-x;}
    void update(int k,int v){
        for(int i = k; i <= LS.size(); i+=lb(i)){
            t[i] = max(t[i],v);
        }
    }
    int quary(int k){
        int res = 0;
        for(int i = k; i >= 1; i-=lb(i)) res=max(res,t[i]);
        return res;
    }
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        for(int i = 0; i < n;i++){
            LS.push_back(nums[i]);
        }
        sort(LS.begin(),LS.end());
        LS.erase(unique(LS.begin(),LS.end()),LS.end());
        int ma = 0;
        for(int i = 0; i < nums.size();i++){
            int idx = getidx(nums[i]);
            int res = quary(idx - 1) + 1;
            update(idx,res);
            ma = max(ma,res);
        }
        return ma;

    }
};
```

###### CF629D

[Problem - 629D - Codeforces](https://codeforces.com/problemset/problem/629/D)

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int,int>
#define endl "\n"
typedef unsigned long long ULL;
typedef long long ll;
const int N = 200005;
const double PI = acos(-1.0);
//ä¸è¦æŠŠé¢˜ç›®æƒ³çš„å¤ªéš¾
int t[N];
int f[N];
int n;
int lb(int x){return x&-x;}
void update(int k,int v){
	for(int i = k; i <= n; i+= lb(i)) t[i] = max(t[i],v);
}
int quary(int k){
	int res = 0;
	for(int i = k; i > 0; i-= lb(i)){
		res = max(res,t[i]);
	}
	return res;
}
struct cake
{
	int v,id;
	bool operator<(const cake &c1)const{
		if(c1.v == v) return id > c1.id;
		return v < c1.v;
	}
}c[N];

void solve(){
	
	cin >> n;
	for(int i = 1; i <= n;i++){
		int r,h;
		cin >> r >> h; 
		c[i] = {r*r*h,i};
	}
	sort(c + 1, c + 1 + n);
	int ma = 0;
	for(int i = 1; i <= n; i++){
		f[i] = quary(c[i].id - 1) + c[i].v;
		update(c[i].id,f[i]);
		ma = max(f[i],ma);
	}
	double res = ma*PI;
	printf("%.9lf\n",res);

}

signed main(){
	std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    std::cout.tie(0);
	int times = 1;
	//cin >> times;
	while(times--){
		solve();
	}
	return 0;
}
```

###### MC0349

[ç é¢˜é›†OJ-åŒºé—´æ•°æ®å¤„ç† (matiji.net)](https://www.matiji.net/exam/brushquestion/49/4497/C2CBD34082148550EF198C50D10DBDC7)

å·§å¦™ç¦»çº¿+æ ‘çŠ¶æ•°ç»„

```c++
const int P = 13331;
const int N = 1000005;
struct qn
{
    int l,r,x,no;
};
struct nums{
    int val,no;
};
int tr[N];
int lb(int x){return x&-x;}
void add(int k){
    for(int i = k; i < N;i+=lb(i)){
        tr[i]++;
    }
}
int quary(int k){
    int res = 0;
    for(int i = k;i > 0;i-=lb(i)) res+=tr[i];
    return res;
}
void solve(){
    vector<qn> qs;
    vector<nums> a;
    int n,m;
    cin >> n >> m;
    int t;
    for(int i = 1; i <= n;i++){
        cin >> t;
        a.push_back({t,i});
    }
    vector<int> res(m + 1);
    sort(a.begin(),a.end(),[&](nums &x,nums & y){return x.val > y.val;});
    for(int i = 1;i<=m;i++){
        int l,r;
        cin >> l >> r >> t;
        qs.push_back({l,r,t,i});
    }
    sort(qs.begin(),qs.end(),[&](qn &a,qn & b){return a.x > b.x;});
    int id = 0;
    for(int i = 0;i < m;i++){
        while(id < n && a[id].val >= qs[i].x){
            add(a[id].no);
            id++;
        }
        int v = quary(qs[i].r) - quary(qs[i].l - 1);
        res[qs[i].no] = v;
    }
    for(int i = 1;i<=m;i++){
        cout << res[i] <<endl;
    }
}
```



### 6.äºŒå‰æœç´¢æ ‘

**å»ºæ ‘:**

```c++
const int N = 1003;
int tree[N<<2], a[N];
int n, m;
unordered_map<int, int> Map;

void Build()
{
    tree[1] = a[1];
    Map[a[1]] = 1;
    for (int i = 2; i <= n; i++)
    {
        int idx = 1;
        while (tree[idx] != -10001)
        {
            if (a[i] > tree[idx])
                idx = rson;
            else
                idx = lson;
        }
        tree[idx] = a[i];
        Map[a[i]] = idx;
    }
}
```

æˆ–è€…:

**ç»“æ„ä½“å®ç°,æ”¹ä»£ç å®ç°å¯»æ‰¾æœ€åä¸¤å±‚çš„èŠ‚ç‚¹æ•°é‡,ä»¥åŠå…ˆåºéå†**

```c++
typedef struct tree{
	int v;
	struct tree *l;
	struct tree *r;
	//tree(int x): v(x),l(NULL),r(NULL) {}
};
int maxd = 0;
void build(tree* &node,int v,int d){
	//cout << maxd << endl;
	if(node==NULL){
		//cout << 1<< endl;
		node = new tree;
		node->v = v;
		node->l=node->r=NULL;
		maxd = max(maxd,d);
	}else if(v>node->v) build(node->r,v,d+1);
	else if(v<=node->v) build(node->l,v,d+1);
}
int ans = 0;
void aorder(tree* node,int d){
	//cout << 1 << endl;
	if(node==NULL) return;
	if(d>=maxd-1) ans++;
	aorder(node->l,d+1);
	aorder(node->r,d+1); 
}
```

### 7.åˆ†å—

å°†ä¸€ä¸ªé•¿åº¦ä¸ºä½ çš„åŒºé—´åˆ†æˆ (n/sqrt(n)) ä¸Šå–æ•´ä¸ªå— å¤æ‚åº¦ æ ¹å·n*logn

**ä¾‹é¢˜:**

**1.P2801 æ•™ä¸»çš„é­”æ³•**

[P2801 æ•™ä¸»çš„é­”æ³• - æ´›è°· | è®¡ç®—æœºç§‘å­¦æ•™è‚²æ–°ç”Ÿæ€ (luogu.com.cn)](https://www.luogu.com.cn/problem/P2801)

```c++
int a[N];
int e[N];//æ’åºçš„å‰¯æœ¬
int be[N],L[N],R[N];
int tag[N];//ç´¯åŠ å€¼
void solve(){
	//åˆå§‹åŒ–å—å·¥ä½œ
	int n,q;
	cin >> n >> q;
	for(int i = 1; i <= n;i++) cin >> a[i];
	int block = sqrt(n);//å—é•¿;
	int tot = (n + block - 1)/block;//å¤šå°‘ä¸ªå—,ä¸Šå–æ•´,æœ€åä¸€å—å¯ä»¥ä¸åˆ°block
	auto cg = [&](int k){
		for(int i = L[k];i <= R[k];i++) e[i] = a[i];
		sort(e + L[k],e + R[k] + 1);
	};//ç»´æŠ¤kè¿™ä¸ªå—çš„æ•°æ®,è¿™é‡Œæ˜¯ç»´æŠ¤å€¼çš„é¡ºåº
	for(int i = 1;i <= tot;i++){
		L[i] = (i-1)*block + 1;
		R[i] = min(i*block,n);
		for(int j = L[i]; j <= R[i];j++) be[j] = i;
		cg(i); //åˆå§‹åŒ–æ¯ä¸€ä¸ªå—
	}
	//å¼€å§‹æŸ¥è¯¢
	while(q--){
		char mod;
		int x,y,v;
		cin >> mod >> x >> y >>v;
		if(mod == 'M'){
			if(be[x]==be[y]){
				for(int i =x; i <= y;i++) a[i] += v;
				cg(be[x]);
			}else{
				for(int i = x; i<= R[be[x]];i++){
					a[i]+=v;
				}
				for(int i = L[be[y]]; i<= y;i++){
					a[i]+=v;
				}
				cg(be[x]);
				cg(be[y]);
				for(int i = be[x] + 1; i <= be[y] - 1;i++){
					tag[i]+=v;
				}
			}
		}else{
			int ans = 0;
			if(be[x]==be[y]){
				for(int i = x;i<=y;i++) if(a[i] + tag[be[i]]>= v) ans++;
			}else{
				for(int i = x; i<= R[be[x]];i++){
					if(a[i] + tag[be[i]]>= v) ans++;
				}
				for(int i = L[be[y]]; i<= y;i++){
					if(a[i] + tag[be[i]] >= v) ans++;
				}
				for(int i = be[x] + 1;i <= be[y] - 1;i++){
					ans += e+R[i] - lower_bound(e+L[i],e+R[i]+1,v-tag[i]) + 1;
				}
			}
			cout << ans <<endl;
		}
	}
}
```

**2.CF551E**

```c++
pair<int,int> a[N];
pair<int,int> e[N];
int be[N],l[N],r[N];
int tag[N];
int tot,block;
int n,q;

int quary(int v){
	int p1,p2,ans1=-1,ans2=-1;
	for(int i = 1; i <= tot;i++){
		int g = v- tag[i];
		p1 = lower_bound(e+l[i],e+r[i]+1,make_pair(g,0ll)) - e;
		if(p1!=r[i]+1&&e[p1].first==g){
			ans1=e[p1].second;
			break;
		}
	}
	for(int i = tot; i >= 1;i--){
		int g = v- tag[i];
		p2 = upper_bound(e+l[i],e+r[i]+1,make_pair(g,n+1ll)) - e - 1;
		if(p2>=0&&e[p2].first==g){
			ans2=e[p2].second;
			break;
		}
	}
	if(ans1==-1||ans2==-1) return -1;
	return ans2 - ans1;
}

void solve(){
	memset(tag,0,sizeof tag);
	cin >> n >> q;
	block = sqrt(n);
	tot = (n + block - 1)/block;
	for(int i = 1; i <= n;i++){
		int t;
		cin >> t;
		a[i] = make_pair(t,i);
	}
	auto cg = [&](int k){
		for(int i = l[k]; i <= r[k];i++){
			e[i] = a[i];
		}
		sort(e + l[k],e+ r[k] +1);
	};
	for(int i = 1 ;i <= tot;i++){
		l[i] = (i-1)*block+1; r[i] = min(n,i*block);
		for(int j = l[i];j<=r[i];j++){
			be[j] = i;
		}
		cg(i);
	}
	while(q--){
		int op;
		cin >> op;
		if(op==1){
			int x,y,v;
			cin >> x >> y >> v;
			if(be[x]==be[y]){
				for(int i = l[be[x]]; i <= r[be[x]];i++) {
					if(a[i].second >= x && a[i].second <= y) a[i].first += v;
				}
				cg(be[x]);
				
			}else{
				for(int i = l[be[x]]; i <= r[be[x]];i++){
					if(a[i].second >= x && a[i].second <= y)  a[i].first += v;
				}
				cg(be[x]);

				for(int i = l[be[y]]; i <= r[be[y]];i++){
					if(a[i].second >= x && a[i].second <= y)  a[i].first += v;
				}
				
				cg(be[y]);
				for(int i = be[x] + 1; i <= be[y] - 1;i++){
					tag[i]+=v;
				}
			}
			
		}else{
			int y;
			cin >> y;
			int t = quary(y);
			cout << t << endl;
		}
	}
}
```

#### åˆ†å—æ±‚topé—®é¢˜

```c++
int e[N];
int l[N],r[N],be[N];
int tag[N];
int block,tot;
//o(æ ¹å·n) åŠ¨æ€æ±‚topké—®é¢˜
void insert(int x){
	tag[be[x]]++;
	e[x]++;
}
//å°†æ•°å­—è£…æ¡¶,æš´åŠ›æ¯ä¸ªæ¡¶,å‘ç°ç»è¿‡ä¸€ä¸ªæ¡¶åå‘ç°ç¬¦åˆæ¡ä»¶,æš´åŠ›æ”¹å—
int quary(int c){
	int res = 0;
	for(int i = 1; i <= tot;i++){
		res+=tag[i];
		if(res >= c){
			int g = res - tag[i];
			for(int j = l[i];j<=r[i];j++){
				g+=e[j];
				if(g>=c){
					return j;
				}
			}
		}
	}
	return -1;
}
```

### 8.è«é˜Ÿ

#### 1.è«é˜Ÿç¦»çº¿(ä¸å¸¦ä¿®æ”¹)

P2709 å°Bçš„è¯¢é—®

æ¿å­

```c++
#include<bits/stdc++.h>
using namespace std;
#define debug(a) cout << "debug : " << (#a) << " = " << a << endl
#define int long long
#define lc u<<1
#define rc u<<1|1
#define PII pair<int,int>
#define endl "\n"
#define il inline
typedef unsigned long long ULL;
typedef long long ll;
il int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x*f;
}
#define rep(i, a, b) for (int i = ll(a); i <= ll(b); ++i)
const int N = 5e4+7;
int block;
struct mdb{
	int l,r,id;
} md[N];
int n,m,k;
int cnt[N],a[N],ans[N];
bool cmp(mdb m1,mdb m2){
	if(m1.l /block !=m2.l/block){
		return m1.l /block < m2.l/block;
	}
	if(m1.l/block&1){
		return m1.r > m2.r;
	}
	return m1.r < m2.r;
}
int res = 0;
void add(int id){
	//if(a[id]>k) return;
	res-=cnt[a[id]]*cnt[a[id]];
	cnt[a[id]]++;
	res+=cnt[a[id]]*cnt[a[id]];
}
void del(int id){
	//if(a[id]>k) return;
	res-=cnt[a[id]]*cnt[a[id]];
	cnt[a[id]]--;
	res+=cnt[a[id]]*cnt[a[id]];
}

void solve(){
	cin >> n >> m >> k;
	block = sqrt(n);
	for(int i = 1; i <= n;i++){
		cin >> a[i];
	}
	for(int i = 1; i <= m;i++){
		cin >>md[i].l >> md[i].r;
		md[i].id = i;
	}
	sort(md+1,md+1+m,cmp);
	int l = 1, r= 0;
	for(int i = 1; i <= m;i++){
		while(l > md[i].l) add(--l);
		while(l < md[i].l) del(l++);
		while(r > md[i].r) del(r--);
		while(r < md[i].r) add(++r);
		ans[md[i].id] = res;
	}
	for(int i = 1; i <= m;i++){
		cout << ans[i] << endl;
	}
}

signed main(){
	std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    std::cout.tie(0);
	int times = 1;
	//cin >> times;
	while(times--){
		solve();
	}
	return 0;
}
```

ç¦»æ•£åŒ–+è«é˜Ÿ

```c++
#include<bits/stdc++.h>
using namespace std;
#define debug(a) cout << "debug : " << (#a) << " = " << a << endl
//#define int long long
#define lc u<<1
#define rc u<<1|1
#define PII pair<int,int>
#define endl "\n"
typedef unsigned long long ULL;
typedef long long ll;
#define rep(i, a, b) for (int i = ll(a); i <= ll(b); ++i)
const int N = 1e6+6;
int n,m;
int a[N],pos[N],ans[N];
vector<int> b;
struct Q {
	int l, r, id;
}q[N];
bool cmp(Q q1, Q q2){
	if(pos[q1.l] != pos[q2.l]){
		return pos[q1.l] < pos[q2.l];
	}
    if(pos[q1.l]&1) return q1.r > q2.r;
	return q1.r < q2.r;
}
int h1[N];
int res = 0;
void add(int id){
	int x = a[id]; //h1è¡¨é‡Œè®°å½•çš„æ˜¯æ¯ä¸ªæ•°å­—åç§»åçš„ä¸‹æ ‡
	h1[x]++; 
	if(h1[x]>1) res^=b[x]; //æ ¹æ®ä¸‹æ ‡æ‹¿çœŸå®å€¼
		
}
void del(int id){
	int x = a[id];
    h1[x]--;
    if(h1[x]>0) res^=b[x];
}

void solve(){
	cin >> n >> m;
	int block = sqrt(n);
	for(int i = 1; i <= n;i++){
		cin >> a[i];
		b.push_back(a[i]);
	}
	sort(b.begin(),b.end());
	b.erase(unique(b.begin(),b.end()),b.end());
	for(int i = 1;i<=n;i++){
		a[i] = lower_bound(b.begin(),b.end(),a[i]) - b.begin();
	}
	for(int i = 1; i <= m;++i){
		cin >> q[i].l >> q[i].r;
		pos[i] = (i+block-1)/block;
		q[i].id = i;
	}
	sort(q+1,q+1+m,cmp);
	int l = 1,r = 0;
	for(int i = 1; i <= m;i++){
		while(q[i].l < l) add(--l);
		while(q[i].l > l) del(l++);
		while(q[i].r > r) add(++r);
		while(q[i].r < r) del(r--);
		ans[q[i].id] =res;
	}
	for(int i = 1; i <= m;i++){
		cout << ans[i] << endl;
	}
}

signed main(){
	std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    std::cout.tie(0);
	int times = 1;
	//cin >> times;
	while(times--){
		solve();
	}
	return 0;
}
```

### 9.å¹³è¡¡æ ‘

##### æ¨¡ç‰ˆ:

```c++
int root,idx;
struct node
{
    int s[2];//s[0]ä»£è¡¨å·¦å„¿å­ï¼Œs[1]ä»£è¡¨å³å„¿å­
    int p;//èŠ‚ç‚¹çš„çˆ¶äº²
    int v;//èŠ‚ç‚¹çš„æƒå€¼
    int size;//ä»¥è¯¥ç‚¹ä¸ºæ ¹çš„å­æ ‘å¤§å°
    int cnt;//è¯¥æƒå€¼çš„æ•°ç›®
    void init(int p1, int v1) //èŠ‚ç‚¹åˆå§‹åŒ–
    {
        p = p1;
        v = v1;
        size = cnt = 1;
    }
}tr[N];
void pushup(int x)//æ—‹è½¬ä¹‹åéœ€è¦é‡æ–°è®¡ç®—å­æ ‘å¤§å°
{
    tr[x].size = tr[tr[x].s[0]].size+tr[tr[x].s[1]].size+tr[x].cnt;//åŠ ä¿©å„¿å­å¤§å°å’Œä¸è‡ªå·±å¤§å°ç›¸åŒçš„ä¸ªæ•°
}
void rotate(int x)//æ—‹è½¬å­æ ‘
{
    int y = tr[x].p, z = tr[y].p;//yä¸ºxèŠ‚ç‚¹çš„çˆ¶äº²ï¼Œzä¸ºyèŠ‚ç‚¹çš„çˆ¶äº²
    int k = tr[y].s[1] == x;//åˆ¤æ–­xä¸ºyçš„å·¦å„¿å­è¿˜æ˜¯å³å„¿å­
    tr[y].s[k] = tr[x].s[1^k];//yçš„å·¦/å³å„¿å­æ›¿æ¢ä¸ºxçš„å³/å·¦å„¿å­
    tr[tr[x].s[1^k]].p = y;//xçš„å³/å·¦å„¿å­æ›¿æ¢ä¸ºy
    tr[x].s[k^1] = y;//xå’Œyçˆ¶å­äº¤æ¢å·¦æ¢å³ï¼Œå³æ¢å·¦
    tr[y].p = x;//yçš„çˆ¶äº²å˜ä¸ºx
    tr[z].s[tr[z].s[1] == y] = x;//zçš„å·¦/å³å„¿å­å˜ä¸ºx
    tr[x].p = z;//xçš„çˆ¶äº²å˜ä¸ºz
    pushup(x), pushup(y);//æ›´æ–°xå’Œyçš„å­æ ‘å¤§å°
}
void splay(int x,int k)//å°†xèŠ‚ç‚¹è½¬åˆ°kä½ç½®ä¸‹é¢
{
    //k == 0æ—¶ï¼Œå°†xèŠ‚ç‚¹è½¬åˆ°æ ¹èŠ‚ç‚¹
    while(tr[x].p != k)
    {
        int y = tr[x].p, z = tr[y].p;
        //å¦‚æœyæ˜¯æ ¹ç›´æ¥æ—‹è½¬ï¼Œå¦åˆ™éœ€è¦å†è½¬
        if (z != k)
        {
            //åˆ¤æ–­x,y,zçš„å½¢çŠ¶æ˜¯ç›´çº¿å‹è¿˜æ˜¯æŠ˜çº¿å‹
            if ((tr[y].s[0] == x)^(tr[z].s[0] == y))//æŠ˜çº¿å‹è½¬x
                rotate(x);
            else//ç›´çº¿å‹è½¬y
                rotate(y);
        }
        rotate(x);
        // cout << "====" << endl;
    }
 
    if (k == 0) root = x;
}
void find(int v)//æŸ¥æ‰¾æƒå€¼ä¸ºvçš„å€¼ï¼Œå¹¶å°†å…¶è½¬ä¸ºæ ¹èŠ‚ç‚¹
{
    int x = root;
    while (tr[x].s[v>tr[x].v]&&v != tr[x].v)//å­˜åœ¨è¿™ä¸ªèŠ‚ç‚¹ï¼Œç›¸åŒè¿”å›ï¼Œå¦åˆ™æ ¹æ®å¤§å°åˆ¤æ–­è½¬åˆ°å·¦/å³å„¿å­
    {
        x = tr[x].s[v>tr[x].v];
    }
    splay(x,0);
}
int get_pre(int v)//æ±‚vçš„å‰é©±
{
    find(v);
    int x = root;
    if (tr[x].v < v) return x;//ä¸å­˜åœ¨vï¼Œè€Œä¸”æ ¹æƒå€¼å°äºvï¼Œæ­¤æ—¶æ ¹èŠ‚ç‚¹ä¸ºå‰é©±ç›´æ¥è¿”å›
    x = tr[x].s[0];
    while (tr[x].s[1]) x = tr[x].s[1];
    splay(x, 0);
    return x;
}
int get_suc(int v)//æ±‚vçš„åç»§
{
    find(v);
    int x = root;
    if (tr[x].v > v) return x;//ä¸å­˜åœ¨vï¼Œè€Œä¸”æ ¹æƒå€¼å¤§äºvï¼Œæ­¤æ—¶æ ¹èŠ‚ç‚¹ä¸ºåé©±ç›´æ¥è¿”å›
    x = tr[x].s[1];
    while (tr[x].s[0]) x = tr[x].s[0];
    splay(x, 0);
    return x;
}
void del(int v)//å°†våˆ é™¤
{
    int pre = get_pre(v);
    int suc = get_suc(v);
    splay(pre,0), splay(suc,pre);//å°†vè½¬ä¸ºå¶å­èŠ‚ç‚¹æ–¹ä¾¿åˆ é™¤
    int del = tr[suc].s[0];
    if (tr[del].cnt > 1)//å¦‚æœä¸ªæ•°ä¸æ­¢ä¸€ä¸ªåˆ å»ä¸€ä¸ª
        tr[del].cnt--, splay(del,0);
    else//å¦åˆ™ç›´æ¥åˆ å»
        tr[suc].s[0] = 0, splay(suc,0);
}
int get_rank(int v)//æŸ¥æ‰¾vçš„æ’å
{
    find(v);
    return tr[tr[root].s[0]].size;
}
int get_val(int k)//æŸ¥è¯¢æ’åä¸ºkçš„æ ‘
{
    int x = root;
    while(1)
    {
        int y = tr[x].s[0];
        if (tr[y].size+tr[x].cnt < k)//å·¦å­æ ‘åŠ æ ¹ä¸ªæ•°å°äºkï¼Œè¯æ˜ç¬¬kä¸ªæ•°åœ¨å³å­æ ‘
        {
            k -= tr[y].size+tr[x].cnt;
            x = tr[x].s[1];
        }
        else//å¦‚æœå·¦å­æ ‘ä¸ªæ•°å¤§äºkï¼Œåœ¨å·¦å­æ ‘ï¼Œå¦åˆ™åœ¨å½“å‰æ ¹ä¸Šï¼›
        {
            if (tr[y].size >= k) x = tr[x].s[0];
            else break;
        }
    }
    splay(x,0);
    return tr[x].v;
}
void insert(int v) //æ’å…¥å¤§å°ä¸ºvçš„èŠ‚ç‚¹
{
    int x = root, p = 0;
    while (x&&tr[x].v != v)//æ‰¾åº”è¯¥æ’å…¥çš„ä½ç½®
    {
        p = x;
        x = tr[x].s[v>tr[x].v];
    }
    if (x) tr[x].cnt++;//å¦‚æœå­˜åœ¨ä¸ªæ•°åŠ 1
    else
    {
        x = ++idx;
        tr[p].s[v>tr[p].v] = x;
        tr[x].init(p,v);
    }
    splay(x,0);
}
```

****

##### **ç”¨æ³•:**

è®°å¾—æ’å…¥ -inf ä¸ inf ä¸¤ä¸ªè™šæ‹Ÿå¤´èŠ‚ç‚¹

##### æ¨¡ç‰ˆäºŒ:

```c++
int n,m;
struct node
{
    int s[2],p,v;
    int rev,same,size,sum,ms,ls,rs;
    //ç¿»è½¬æ ‡è®°,ç›¸åŒæ ‡è®°,å­æ ‘å¤§å°,åŒºé—´å’Œ,æœ€å¤§å­æ®µå’Œ,æœ€å¤§å‰ç¼€å’Œ,æœ€å¤§åç¼€å’Œ
    void init(int _v,int _p) //é¢„å¤„ç†
    {
        s[0] = s[1] = 0,p = _p,v = _v;
        rev = same = 0;
        size = 1,sum = ms =v;
        ls = rs = max(v,0ll);
    }
}tr[N];
int root;
int nodes[N],tt;//åƒåœ¾å›æ”¶æ•°ç»„,ttä¸ºå…¶å¤§å°
int w[N];
void pushup(int x) //å‘ä¸Šä¼ é€’
{
    auto &u = tr[x],&l = tr[u.s[0]],&r = tr[u.s[1]];
    u.size = l.size + r.size + 1;
    u.sum = l.sum + r.sum + u.v;
    u.ls = max(l.ls,l.sum + u.v + r.ls);
    u.rs = max(r.rs,r.sum + u.v + l.rs);
    u.ms = max(max(l.ms,r.ms),l.rs + u.v + r.ls);//å¤„ç†å„ä¸ªæ•°æ®
}
void pushdown(int x) //å‘ä¸‹ä¼ é€’
{
    auto &u = tr[x],&l = tr[u.s[0]], &r = tr[u.s[1]];
    if(u.same) //è‹¥æœ‰ç›¸åŒæ ‡è®°,åˆ™ç¿»è½¬æ ‡è®°å°±å¹¶ä¸éœ€è¦
    {
        u.same = u.rev = 0;
        if(u.s[0])  l.same = 1,l.v = u.v,l.sum = l.v * l.size; 
        if(u.s[1])  r.same = 1,r.v = u.v,r.sum = r.v * r.size;
        if(u.v > 0)
        {
            if(u.s[0])  l.ms = l.ls = l.rs = l.sum;
            if(u.s[1])  r.ms = r.ls = r.rs = r.sum;
        }else
        {
            //å·¦å³å­æ ‘æ•°æ®å¤„ç†
            if(u.s[0])  l.ms = l.v,l.ls = l.rs = 0;
            if(u.s[1])  r.ms = r.v,r.ls = r.rs = 0;
        }
    }else
    if(u.rev)
    {
        //ç¿»è½¬
        u.rev = 0,l.rev ^= 1,r.rev ^= 1;
        swap(l.ls,l.rs),swap(r.ls,r.rs);
        swap(l.s[0],l.s[1]),swap(r.s[0],r.s[1]);
    }
}
void rotate(int x)
{
    //å‘ä¸Šæ—‹è½¬
    int y = tr[x].p,z = tr[y].p;
    int k = tr[y].s[1] == x;
    tr[z].s[tr[z].s[1] == y] = x,tr[x].p = z;
    tr[y].s[k] = tr[x].s[k ^ 1],tr[tr[x].s[k ^ 1]].p = y;
    tr[x].s[k ^ 1] = y,tr[y].p = x;
    pushup(y),pushup(x);
}
void splay(int x,int k)
{
    while (tr[x].p != k)
    {
        int y = tr[x].p, z = tr[y].p;
        if (z != k)
            if ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);
            else rotate(y);
        rotate(x);
    }
    if (!k) root = x;
}
//ä¼¸å±•
int get_k(int k) //æŸ¥è¯¢ç¬¬kä¸ªæ•°
{
    int u = root;
    while (u)
    {
        pushdown(u);
        if (tr[tr[u].s[0]].size >= k) u = tr[u].s[0];
        else if (tr[tr[u].s[0]].size + 1 == k) return u;
        else k -= tr[tr[u].s[0]].size + 1, u = tr[u].s[1];
    }
}
int build(int l,int r,int p) //å»ºé€ å­æ ‘
{
    int mid = l + r >> 1;
    int u = nodes[tt -- ];
    tr[u].init(w[mid], p);
    if (l < mid) tr[u].s[0] = build(l, mid - 1, u);
    if (mid < r) tr[u].s[1] = build(mid + 1, r, u);
    pushup(u);
    return u;
}
void del(int u) //delete æ“ä½œ
{
    if(tr[u].s[0])  del(tr[u].s[0]);
    if(tr[u].s[1])  del(tr[u].s[1]);
    nodes[ ++ tt] = u; //åƒåœ¾å›æ”¶
}
//åœ¨posiä½ç½®æ’å…¥ä¸€ä¸ªåºåˆ—
void insert(int posi,int tot){
    //å°†å€¼ä¼ å…¥w
    for(int i = 0;i <tot;i++) cin >> w[i];
     int l = get_k(posi + 1), r = get_k(posi + 2);
    splay(l, 0), splay(r, l);
    int u = build(0, tot - 1, r);
    tr[r].s[0] = u;
    pushup(r), pushup(l);
}
//åœ¨posiä½ç½®åè¿ç»­totä¸ªä½ç½®
void delt(int posi,int tot){
    int l = get_k(posi), r = get_k(posi + tot + 1);
        splay(l, 0), splay(r, l);
        del(tr[r].s[0]);
        tr[r].s[0] = 0;
        pushup(r), pushup(l);

}
void makesame(int posi,int tot,int c){
    int l = get_k(posi), r = get_k(posi + tot + 1);
        splay(l, 0), splay(r, l);
        auto& son = tr[tr[r].s[0]];
        son.same = 1, son.v = c, son.sum = c * son.size;
        if (c > 0) son.ms = son.ls = son.rs = son.sum;
        else son.ms = c, son.ls = son.rs = 0;
        pushup(r), pushup(l);
}
void reverse(int posi,int tot){
    int l = get_k(posi), r = get_k(posi + tot + 1);
    splay(l, 0), splay(r, l);
    auto& son = tr[tr[r].s[0]];
    son.rev ^= 1;
    swap(son.ls, son.rs);
    swap(son.s[0], son.s[1]);
    pushup(r), pushup(l);
}
int get_sum(int posi,int tot){
    int l = get_k(posi), r = get_k(posi + tot + 1);
    splay(l, 0), splay(r, l);
    return tr[tr[r].s[0]].sum;
}
int max_sum(){
    return tr[root].ms;
}
```



```c++
#include"bits/stdc++.h"
using namespace std;
const int N = 500010,INF = 1e9;
#define inl inline
#define reg register
//#define ll long long
int n,m;
struct node
{
    int s[2],p,v;
    int rev,same,size,sum,ms,ls,rs;
    //ç¿»è½¬æ ‡è®°,ç›¸åŒæ ‡è®°,å­æ ‘å¤§å°,åŒºé—´å’Œ,æœ€å¤§å­æ®µå’Œ,æœ€å¤§å‰ç¼€å’Œ,æœ€å¤§åç¼€å’Œ
    void init(int _v,int _p) //é¢„å¤„ç†
    {
        s[0] = s[1] = 0,p = _p,v = _v;
        rev = same = 0;
        size = 1,sum = ms =v;
        ls = rs = max(v,0);
    }
}tr[N];
int root;
int nodes[N],tt;//åƒåœ¾å›æ”¶æ•°ç»„,ttä¸ºå…¶å¤§å°
int w[N];
void pushup(int x) //å‘ä¸Šä¼ é€’
{
    auto &u = tr[x],&l = tr[u.s[0]],&r = tr[u.s[1]];
    u.size = l.size + r.size + 1;
    u.sum = l.sum + r.sum + u.v;
    u.ls = max(l.ls,l.sum + u.v + r.ls);
    u.rs = max(r.rs,r.sum + u.v + l.rs);
    u.ms = max(max(l.ms,r.ms),l.rs + u.v + r.ls);
ã€€ã€€//å¤„ç†å„ä¸ªæ•°æ®
}
void pushdown(int x) //å‘ä¸‹ä¼ é€’
{
    auto &u = tr[x],&l = tr[u.s[0]], &r = tr[u.s[1]];
    if(u.same) //è‹¥æœ‰ç›¸åŒæ ‡è®°,åˆ™ç¿»è½¬æ ‡è®°å°±å¹¶ä¸éœ€è¦
    {
        u.same = u.rev = 0;
        if(u.s[0])  l.same = 1,l.v = u.v,l.sum = l.v * l.size; 
        if(u.s[1])  r.same = 1,r.v = u.v,r.sum = r.v * r.size;
ã€€ã€€ã€€ã€€ã€€
        if(u.v > 0)
        {
            if(u.s[0])  l.ms = l.ls = l.rs = l.sum;
            if(u.s[1])  r.ms = r.ls = r.rs = r.sum;
        }else
        {
            if(u.s[0])  l.ms = l.v,l.ls = l.rs = 0;
            if(u.s[1])  r.ms = r.v,r.ls = r.rs = 0;
        }
ã€€ã€€ã€€ã€€ã€€//å·¦å³å­æ ‘æ•°æ®å¤„ç†
    }else
    if(u.rev)
    {
        u.rev = 0,l.rev ^= 1,r.rev ^= 1;
        swap(l.ls,l.rs),swap(r.ls,r.rs);
        swap(l.s[0],l.s[1]),swap(r.s[0],r.s[1]);
ã€€ã€€ã€€ã€€ã€€//ç¿»è½¬
    }
}
void rotate(int x)
{
    int y = tr[x].p,z = tr[y].p;
    int k = tr[y].s[1] == x;
    tr[z].s[tr[z].s[1] == y] = x,tr[x].p = z;
    tr[y].s[k] = tr[x].s[k ^ 1],tr[tr[x].s[k ^ 1]].p = y;
    tr[x].s[k ^ 1] = y,tr[y].p = x;
    pushup(y),pushup(x);
ã€€ã€€//å‘ä¸Šæ—‹è½¬
}
void splay(int x,int k)
{
    while (tr[x].p != k)
    {
        int y = tr[x].p, z = tr[y].p;
        if (z != k)
            if ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);
            else rotate(y);
        rotate(x);
    }
    if (!k) root = x;
}
//ä¼¸å±•
int get_k(int k) //æŸ¥è¯¢ç¬¬kä¸ªæ•°
{
    int u = root;
    while (u)
    {
        pushdown(u);
        if (tr[tr[u].s[0]].size >= k) u = tr[u].s[0];
        else if (tr[tr[u].s[0]].size + 1 == k) return u;
        else k -= tr[tr[u].s[0]].size + 1, u = tr[u].s[1];
    }
}
int build(int l,int r,int p) //å»ºé€ å­æ ‘
{
    int mid = l + r >> 1;
    int u = nodes[tt -- ];
    tr[u].init(w[mid], p);
    if (l < mid) tr[u].s[0] = build(l, mid - 1, u);
    if (mid < r) tr[u].s[1] = build(mid + 1, r, u);
    pushup(u);
    return u;
}
void dfs(int u) //delete æ“ä½œ
{
    if(tr[u].s[0])  dfs(tr[u].s[0]);
    if(tr[u].s[1])  dfs(tr[u].s[1]);
    nodes[ ++ tt] = u; //åƒåœ¾å›æ”¶
ã€€ã€€
}
int main(void)
{
    for(int i = 1;i < N;i ++) nodes[ ++ tt] = i;
    //nit [1,n] -> åƒåœ¾å›æ”¶ç«™
    scanf("%d%d",&n,&m);
    tr[0].ms = -INF;
    w[0] = w[n+1] = -INF;
    for(int i = 1;i <= n;i ++)  scanf("%d",&w[i]);
    root = build(0,n + 1,0);
    char op[20];
 
    while (m -- )
    {
 
        scanf("%s", op);
        if (!strcmp(op, "INSERT"))
        {
            int posi, tot;
            scanf("%d%d", &posi, &tot);
            for (int i = 0; i < tot; i ++ ) scanf("%d", &w[i]);
            int l = get_k(posi + 1), r = get_k(posi + 2);
            splay(l, 0), splay(r, l);
            int u = build(0, tot - 1, r);
            tr[r].s[0] = u;
            pushup(r), pushup(l);
        }
        else if (!strcmp(op, "DELETE"))
        {
            int posi, tot;
            scanf("%d%d", &posi, &tot);
            int l = get_k(posi), r = get_k(posi + tot + 1);
            splay(l, 0), splay(r, l);
            dfs(tr[r].s[0]);
            tr[r].s[0] = 0;
            pushup(r), pushup(l);
        }
        else if (!strcmp(op, "MAKE-SAME"))
        {
            int posi, tot, c;
            scanf("%d%d%d", &posi, &tot, &c);
            int l = get_k(posi), r = get_k(posi + tot + 1);
            splay(l, 0), splay(r, l);
            auto& son = tr[tr[r].s[0]];
            son.same = 1, son.v = c, son.sum = c * son.size;
            if (c > 0) son.ms = son.ls = son.rs = son.sum;
            else son.ms = c, son.ls = son.rs = 0;
            pushup(r), pushup(l);
        }
        else if (!strcmp(op, "REVERSE"))
        {
            int posi, tot;
            scanf("%d%d", &posi, &tot);
            int l = get_k(posi), r = get_k(posi + tot + 1);
            splay(l, 0), splay(r, l);
            auto& son = tr[tr[r].s[0]];
            son.rev ^= 1;
            swap(son.ls, son.rs);
            swap(son.s[0], son.s[1]);
            pushup(r), pushup(l);
        }
        else if (!strcmp(op, "GET-SUM"))
        {
            int posi, tot;
            scanf("%d%d", &posi, &tot);
            int l = get_k(posi), r = get_k(posi + tot + 1);
            splay(l, 0), splay(r, l);
            printf("%d\n", tr[tr[r].s[0]].sum);
        }
        else printf("%d\n", tr[root].ms); //MAX-SUM
    }
 
    return 0;
}
/*
è¾“å…¥æ ·ä¾‹ 1
9 8 
2 -6 3 5 1 -5 -3 6 3 
GET-SUM 5 4
MAX-SUM
INSERT 8 3 -5 7 2
DELETE 12 1
MAKE-SAME 3 3 2
REVERSE 3 6
GET-SUM 5 4
MAX-SUM
*/
```



## <a name = "zfcp">å…­ å­—ç¬¦ä¸²ç¯‡</a>

### 1.æœ€å°è¡¨ç¤ºæ³•

**æœ€å°è¡¨ç¤ºæ³•ç”¨æ¥å¯»æ‰¾å¾ªç¯åŒæ„å­—ç¬¦ä¸²çš„æœ€å°å­—å…¸åº,å…¶æ—¶é—´å¤æ‚åº¦O(N)æ¯”æš´åŠ›å¾ªç¯æ›´ä¼˜**

#### æ­¥éª¤

**1.ç ´ç¯æˆé“¾**

â€‹	**å°†å­—ç¬¦ä¸²æ‰©å±•ä¸¤å€ åŠnew_s = s + s;**

**2.åˆå§‹åŒ– æ¯”è¾ƒä¸‹æ ‡ i,j; æ¯”è¾ƒé•¿åº¦ k;**

â€‹	**ä¸€èˆ¬ i = 0; j = 1;k = 0;**

**3.æ¯”è¾ƒ**

â€‹	**å¦‚æœ new_s[i + k] == new_s[j + k] åˆ™k++;**

â€‹	**å¦‚æœ new_s[i + k] > new_s[j + k] åˆ™ i = i + k + 1;å³i --- i+k åŒºé—´ä¸€å®šæ¯”jå¤§,å³è¢«æ·˜æ±°**

â€‹	**å¦‚æœ new_s[i + k] < new_s[j  + k] åˆ™ j = j + k + 1 ä¸ä¸Šé¢åŒç†**

â€‹	**å¦‚æœi==j æˆ‘ä»¬è®¾ç½®j++;**

**4.å¾ªç¯ç»“æŸ æ‰¾åˆ°æœ€å°ä¸‹æ ‡ å³min(i,j);**

#### ä»£ç å¦‚ä¸‹

```c++
void solve(){
    string s;
    cin >> s;
    int n = s.size();
    string new_s = s + s;
    int i = 0,j = 1, k = 0;
    while(i < n && j < n && k < n) {
        if(new_s[j + k] == new_s[i + k]) k++;
        else{
            if(new_s[j+k] < new_s[i+k]) i = i + k + 1;
            else if(new_s[j+k] > new_s[i+k]) j = j + k + 1;
            if(i == j) j++;
            k = 0;
        }
        
    }
    string res = new_s.substr(min(i,j),n);
}
```

### 2.é¢„å¤„ç†å›æ–‡æ•°

```c++
vector<int> pal;

auto init = [] {
    // ä¸¥æ ¼æŒ‰é¡ºåºä»å°åˆ°å¤§ç”Ÿæˆæ‰€æœ‰å›æ–‡æ•°ï¼ˆä¸ç”¨å­—ç¬¦ä¸²è½¬æ¢ï¼‰
    for (int base = 1; base <= 10000; base *= 10) {
        // ç”Ÿæˆå¥‡æ•°é•¿åº¦å›æ–‡æ•°
        for (int i = base; i < base * 10; i++) {
            int x = i;
            for (int t = i / 10; t; t /= 10) {
                x = x * 10 + t % 10;
            }
            pal.push_back(x);
        }
        // ç”Ÿæˆå¶æ•°é•¿åº¦å›æ–‡æ•°
        if (base <= 1000) {
            for (int i = base; i < base * 10; i++) {
                int x = i;
                for (int t = i; t; t /= 10) {
                    x = x * 10 + t % 10;
                }
                pal.push_back(x);
            }
        }
    }
    pal.push_back(1000000001); // å“¨å…µï¼Œé˜²æ­¢ä¸‹é¢ä»£ç ä¸­çš„ i ä¸‹æ ‡è¶Šç•Œ
    return 0;
}();
```



### 3.å­—ç¬¦ä¸²å“ˆå¸Œ

![image-20240105140044925](img/image-20240105140044925-1704434451598-2.png)



æ˜¯ä¸€ä¸ªç±»ä¼¼äºå‰ç¼€å’Œçš„æ€æƒ³

![image-20240105140343327](img/image-20240105140343327-1704434634451-5.png)

#### ä»£ç æ¨¡ç‰ˆ

åŠ å“¨å…µçš„å­—ç¬¦ä¸²hash

```c++
typedef unsigned long long ULL;
//æ³¨æ„åœ¨åŸæœ‰çš„så‰é¢åŠ ä¸€ä¸ªå“¨å…µ"&"



const int P = 131;//å–ä¸€ä¸ªè´¨æ•°; 
const int N = 100005;//å­—ç¬¦ä¸²é•¿åº¦ 
ULL p1[N],h[N];//p1[i] = P^i,Pçš„iæ¬¡æ–¹,h[i]ä¸ºs[0-i]çš„hashå€¼ 
int n;
//åˆå§‹åŒ– 
void init(){
	p1[0] = 1;
	h[0] = 0;
	for(int i = 1; i <= n;i++){
		p1[i] = p1[i - 1]*P;
		h[i] = h[i - 1]*P+s[i];
	}
}

ULL get(int l,int r){
	return h[r] - h[l-1]*p1[r - l + 1]; 
}
//åˆ¤æ–­ä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦ç›¸åŒ 
bool substr(int l1,int r1,int l2,int r2){
	 return get(l1,r1) == get(l2,r2); 
} 
```

åŸå­—ç¬¦ä¸²hash

```c++
const int P = 131;//å–ä¸€ä¸ªè´¨æ•°; 
const int N = 100005;//å­—ç¬¦ä¸²é•¿åº¦ 
ULL p1[N],h[N];//p1[i] = P^i,Pçš„iæ¬¡æ–¹,h[i]ä¸ºs[0-i]çš„hashå€¼ 
int n;
string s;
//åˆå§‹åŒ– 
void init(){
	p1[0] = 1;
	h[0] = s[0];
	for(int i = 1; i <= n;i++){
		p1[i] = p1[i - 1]*P;
		h[i] = h[i - 1]*P+s[i - 1];
	}
}

ULL get(int l,int r){
	return h[r] - h[l]*p1[r - l + 1]; 
}
//åˆ¤æ–­ä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦ç›¸åŒ 
bool substr(int l1,int r1,int l2,int r2){
	 return get(l1,r1) == get(l2,r2); 
} 
void solve(){
	int m;
	cin >> m;
	set<ULL>se;
	for(int i = 0; i < m; i++){
		cin >> s;
		n = s.size();
		//s = "&" + s;
		init();
		se.insert(h[n]);
	}
	cout << se.size();

}
```

### 4.å­—å…¸æ ‘

**æ¦‚å¿µï¼šå­—å…¸æ ‘ï¼ˆTrieTreeï¼‰ï¼Œæ˜¯ä¸€ç§[æ ‘å½¢ç»“æ„](https://so.csdn.net/so/search?q=æ ‘å½¢ç»“æ„&spm=1001.2101.3001.7020)ï¼Œå…¸å‹åº”ç”¨æ˜¯ç”¨äºç»Ÿè®¡ï¼Œæ’åºå’Œä¿å­˜å¤§é‡çš„å­—ç¬¦ä¸²ï¼ˆä½†ä¸ä»…é™äºå­—ç¬¦ä¸²,å¦‚01å­—å…¸æ ‘ï¼‰ã€‚ä¸»è¦æ€æƒ³æ˜¯åˆ©ç”¨å­—ç¬¦ä¸²çš„å…¬å…±å‰ç¼€æ¥èŠ‚çº¦å­˜å‚¨ç©ºé—´ã€‚å¾ˆå¥½åœ°åˆ©ç”¨äº†ä¸²çš„å…¬å…±å‰ç¼€ï¼ŒèŠ‚çº¦äº†å­˜å‚¨ç©ºé—´ã€‚å­—å…¸æ ‘ä¸»è¦åŒ…å«ä¸¤ç§æ“ä½œï¼Œæ’å…¥å’ŒæŸ¥æ‰¾ã€‚**

#### ä»£ç 

```c++
const int N = 100005;
int son[N][26],cnt[N],idx; //éƒ½åˆå§‹åŒ–ä¸º0; 
void insert(string s){
	int p = 0; //ä»0å¼€å§‹ å³æ ¹ 
	for(int i = 0; i < s.size(); i++){
		int ed = s[i] - 'a'; //é€‰æ‹©å­˜æ”¾ä½ç½® 
		if(son[p][ed] == 0) son[p][ed] = ++idx;//å¦‚æœå­˜æ”¾ä½ç½®ä¸å­˜åœ¨å¼€è¾Ÿä¸€ä¸ªä½ç½®ä¸º++idx  æ³¨æ„idxåˆå§‹ä¸º0æ‰€ä»¥++idxæ˜¯1ä»1å¼€å§‹åˆ†é… 
		p = son[p][ed]; //på¾€ä¸‹èµ°å‘æ ‘æˆ–è€…é“¾è¡¨ä¸€æ ·; 
	}
	cnt[p]++; //æŠŠè¿™ä¸ªèŠ‚ç‚¹æ ‡è®°ä¸ºçº¢è‰² å³æœ‰å­—ç¬¦åœ¨è¿™é‡Œç»“æŸ 
}
int find(string s){
	int p = 0;
	for(int i = 0; i < s.size();i++){
		int x = s[i] - 'a';
		if(son[p][x] == 0) return 0;//æ²¡æœ‰è¯¥å­—ç¬¦ä¸²;
		p = son[p][x]; 
	}
	return cnt[p];//è¯¥å­—ç¬¦ä¸²çš„å‡ºç°æ¬¡æ•° 
} 
//findçš„é€’å½’å†™æ³• å¯åˆ©äºæœç´¢
bool find2(string s,int index,int p){
	if(index==s.size()) return cnt[p]>=1;
	int ed = s[i] - 'a';
	if(son[p][ed]==0) return false;
	find(s,index+1,son[p][ed]);
	return false;
}
```

#### ä¾‹é¢˜

##### (1)åŠ›æ‰£208

 [208. å®ç° Trie (å‰ç¼€æ ‘) - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/implement-trie-prefix-tree/description/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china)

ä»£ç 

```c++
class Trie {
public:
    static const int N = 100005;
    int son[N][26];
    int cnt[N];
    int idx = 0;
    Trie() {
        memset(son,0,sizeof son);
        memset(cnt,0,sizeof cnt);
    }
    
    void insert(string word) {
        int p = 0;
        for(int i = 0; i < word.size();i++){
            int ed = word[i] - 'a';
            if(son[p][ed] == 0) son[p][ed] = ++idx;
            p = son[p][ed];
        }
        cnt[p]++;
    }
    //æ˜¯å¦æœ‰å•è¯
    bool search(string word) {
        int p = 0;
        for(int i = 0; i < word.size(); i++){
            int ed = word[i] - 'a';
            if(son[p][ed]==0) return false;
            p = son[p][ed];
        }
        return cnt[p]>0;
    }
    //æ˜¯å¦å­˜åœ¨å‰ç¼€
    bool startsWith(string prefix) {
         int p = 0;
        for(int i = 0; i < prefix.size(); i++){
            int ed = prefix[i] - 'a';
            if(son[p][ed]==0) return false;
            p = son[p][ed];
        }
        return true;
    }
};
```

##### (2)åŠ›æ‰£820

[820. å•è¯çš„å‹ç¼©ç¼–ç  - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/short-encoding-of-words/description/)

```c++
class Solution {
public:
    static const int N = 10005;
    int son[N][26],cnt[N],idx = 0;
    int ans = 0;
    void insert(string s){
        int p = 0;
        bool flag = false;
        for(int i = 0; i < s.size();i++){
            int ed= s[i] - 'a';
            if(son[p][ed]==0){
                son[p][ed] = ++idx;
                flag = true;
            }
            p = son[p][ed];
        }
        if(flag){
            ans+=1+s.size();
        }
    }
    static bool cmp(string s1,string s2){
        return s1.size() > s2.size();
    }
    int minimumLengthEncoding(vector<string>& words) {
        memset(son,0,sizeof son);
        memset(cnt,0,sizeof cnt);
        sort(words.begin(),words.end(),cmp);
        for(int i = 0; i < words.size();i++){
            reverse(words[i].begin(),words[i].end());
            insert(words[i]);
        }
        return ans;
    }
};
```

##### (3)åŠ›æ‰£211

[211. æ·»åŠ ä¸æœç´¢å•è¯ - æ•°æ®ç»“æ„è®¾è®¡](https://leetcode.cn/problems/design-add-and-search-words-data-structure/)

```c++
class WordDictionary {
public:
    static const int N = 10005;
    int son[N][26],cnt[N],idx;
    WordDictionary() {
        memset(son,0,sizeof son);
        memset(cnt,0,sizeof cnt);
        idx = 0;
    }
    
    void addWord(string word) {
        int p = 0;
        for(int i = 0; i < word.size();i++){
            int ed = word[i] - 'a';
            if(son[p][ed]==0) son[p][ed] = ++idx;
            p = son[p][ed];
        }
        cnt[p]++;
    }
    bool dfs(string word,int index,int p){
        if(index == word.size()){
            return cnt[p]>=1;
        }
        char x = word[index];
        if(x >= 'a' && x <= 'z'){
            int ed = x - 'a';
            if(son[p][ed] && dfs(word,index+1,son[p][ed])){
                return true;
            }
        }
        if(x == '.'){
            for(int i = 0; i <26; i++){
                int u = i;
                if(son[p][u]&&dfs(word,index+1,son[p][u])) return true;
            }
        }
        return false;
    }
    bool search(string word) {
        return dfs(word,0,0);
    }
};
```

##### (4)åŠ›æ‰£472

##### "éš¾ é‡ç‚¹ å¤šç†è§£"

[472. è¿æ¥è¯](https://leetcode.cn/problems/concatenated-words/)

```c++
class Solution {
public:
    static const int N = 200005;
    int son[N][26],cnt[N],idx,vis[N];
    void insert(string& s){
        int p = 0;
        for(int i = 0; i <s.size();i++){
            int ed = s[i] - 'a';
            if(son[p][ed] == 0) son[p][ed] = ++idx;
            p = son[p][ed];
        }
        cnt[p]++;
    }

    bool find(string& s,int index){
        if(index>=s.size()){
            return true;
        }
        if(vis[index]) return false;
        vis[index] = 1;
        int p = 0;
        for(int i = index; i <s.size();i++){
            int ed = s[i] - 'a';
            if(son[p][ed]==0) return false;
            p = son[p][ed];
            if(cnt[p]){
                if(find(s,i+1)){ //åˆ¤æ–­åé¢çš„è¯è¡Œä¸è¡Œ åŠ èµ·æ¥èƒ½å¦å‡‘å‡ºä¸€ä¸ªæ•´çš„å•è¯
                    return true;
                }
            }
        }
        return false;
    }

    
    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {
        memset(son,0,sizeof son);
        memset(cnt,0,sizeof cnt);
        idx = 0;
        vector<string> res;
        sort(words.begin(),words.end(),[](string& s1,string& s2){
            return s1.size() < s2.size();
        });
        for(string &s:words){
            memset(vis,0,sizeof vis);
            if(find(s,0)){
                res.push_back(s);
            }else{
                insert(s);
            }
        }
        return res;
        

    }
};
```

##### (5)åŠ›æ‰£648

[648. å•è¯æ›¿æ¢](https://leetcode.cn/problems/replace-words/)

```c++
class Solution {
public:
    static const int N = 100005;
    int son[N][26],cnt[N],idx;
    void insert(string s){
        int p = 0;
        for(int i = 0; i < s.size();i++){
            int ed = s[i] - 'a';
            if(son[p][ed] == 0) son[p][ed] = ++idx;
            p = son[p][ed];
        }
        cnt[p]++;
    }

    string s1;
    bool find(string s){
        int p = 0;
        for(int i = 0; i < s.size(); i++){
            int ed = s[i] - 'a';
            if(son[p][ed]==0) return false;
            s1+=s[i];
            p = son[p][ed];
            if(cnt[p]){
                return true;
            }
        }
        return false;
    }

    string replaceWords(vector<string>& dictionary, string sentence) {
        vector<string> strs;
        memset(son,0,sizeof son);
        memset(cnt,0,sizeof cnt);
        idx = 0;
        int n = sentence.size();
        string s;
        for(int i =0; i < n;i++){
            if(sentence[i]==' '){
                strs.push_back(s);
                s="";
            }else{
                s+=sentence[i];
            }
        }
        if(sentence[n-1]!=' '){
            strs.push_back(s);
        }
        for(int i = 0; i < dictionary.size();i++){
            insert(dictionary[i]);
        }
        vector<string> res;
        for(int i = 0; i < strs.size();i++){
            s1="";
            if(find(strs[i])){
                res.push_back(s1);
            }else{
                res.push_back(strs[i]);
            }
        }
        string ans = "";
        for(int i = 0; i < res.size() - 1; i++){
            ans+=res[i]+" ";
        }
        ans+=res[res.size()-1];
        return ans;

    }
};
```

### 5.KMP

![image-20240127175655578](img/image-20240127175655578.png)

#### æ¦‚å¿µ

![image-20240125211028844](img/image-20240125211028844.png)

![image-20240125211215474](img/image-20240125211215474.png)

![image-20240125211301102](img/image-20240125211301102.png)

![image-20240125211341766](img/image-20240125211341766.png)

#### ä»£ç 

```c++
const int N = 100005;
int n,m;
string s, target;
int ne[N];
void get(){
	ne[1] = 0; //å½“é•¿åº¦ä¸º 1æœ€é•¿å…¬å…±å‰åç¼€ä¸º0;
	int j = 0; //jæ˜¯é¢„åˆ¤æŒ‡é’ˆ,è¿›å¯æ”»(è¿›å°±ç›´æ¥+1)é€€å¯å®ˆ é€€å°±j=ne[j]; å› ä¸ºæˆ‘ä»¬éƒ½æ˜¯ç”¨j+1å»è¯•æ¢ 
	for(int i = 2; i <= m;i++){ //iä»2å¼€å§‹ 
		while(j &&target[j + 1]!=target[i]) j = ne[j];
		 if(target[j+1] == target[i]) j++;
		 ne[i] = j; 
	} 
}
void solve(){
	cin >> s >> target;
	n = s.size();
	m = target.size();
	s = "*"+s; //åŠ ä¸ªå“¨å…µä½¿ç¼–å·ä»1å¼€å§‹ 
	target = "*"+target;
	get();
	int j = 0; 
	for(int i = 1; i <= n; i++){
		while(j && s[i] != target[j+1]) j = ne[j];
		if(s[i] == target[j+1]) j++;
		if(j==m) cout << i - j + 1 << endl; //æ‰“å°å…¨éƒ¨åŒ¹é…çš„ä¸‹æ ‡ 
	} 
	for(int i = 1; i <= m; i++) cout << ne[i] <<" "; //æ‰“å°neæ•°ç»„ 
}
```

**ä¾‹é¢˜:**

[Problem - 126B - Codeforces](https://codeforces.com/problemset/problem/126/B)

### 6.æ‰©å±•KMP(Zå‡½æ•°)

#### æ¦‚å¿µ

![1706345711745](img/1706345711745.png)



![image-20240127172212224](img/image-20240127172212224.png)

![image-20240127175617992](img/image-20240127175617992.png)

#### ä»£ç 

##### 1.sä¸sè‡ªèº« å³zå‡½æ•°å¦‚ä½•æ±‚

```c++
void get_z(string s){
	int n = s.size();
	s = "*"+s;//åŠ ä¸ªå“¨å…µ
	z[1] = n;
	for(int i = 2,l,r = 0; i <= n; i++){
		if(i<=r) z[i] = min(r - i + 1, z[i - l + 1]);
		while(s[1+z[i]]==s[i+z[i]]) z[i]++;
		if(i+z[i]-1>r) l = i, r = i+z[i]-1; 
	} 
}
```



##### 2.sä¸t æ±‚tçš„æ¯ä¸€ä¸ªiå¯¹åº”sçš„lcp(éœ€è¦ä¾èµ–ä¹‹å‰çš„zå‡½æ•°)

```c++
void get_p(string s,string t){
	int n = s.size();
	int m = t.size();
	s = "*"+s; //åŠ ä¸ªå“¨å…µ
	t = "*"+t;
	for(int i = 1,l,r=0; i <= m; i++){ //è¦ä»1å¼€å§‹äº†,å› ä¸ºæ— æ³•é¢„çŸ¥ z[1] == m; 
		if(i<=r) p1[i] = min(z[i - l + 1],r - i + 1);//æ³¨æ„è¿™è¾¹æ˜¯zä¸æ˜¯p,å› ä¸ºå¯¹åº”çš„æ˜¯sçš„å‰ç¼€å³så¯¹åº”çš„z
		while(1+p1[i] <= n && i + p1[i] <= m && s[1+p1[i]] == t[i+p1[i]]) p1[i]++;
		if(i+p1[i]-1>r) l = i,r = i+p1[i] - 1;
	} 

```

#### ä¾‹é¢˜

[3031. å°†å•è¯æ¢å¤åˆå§‹çŠ¶æ€æ‰€éœ€çš„æœ€çŸ­æ—¶é—´ II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/minimum-time-to-revert-word-to-initial-state-ii/description/)

é¢˜ç›®å¤§æ„:

```
ç»™ä½ ä¸€ä¸ªä¸‹æ ‡ä» 0 å¼€å§‹çš„å­—ç¬¦ä¸² word å’Œä¸€ä¸ªæ•´æ•° k ã€‚

åœ¨æ¯ä¸€ç§’ï¼Œä½ å¿…é¡»æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š

ç§»é™¤ word çš„å‰ k ä¸ªå­—ç¬¦ã€‚
åœ¨ word çš„æœ«å°¾æ·»åŠ  k ä¸ªä»»æ„å­—ç¬¦ã€‚
æ³¨æ„ æ·»åŠ çš„å­—ç¬¦ä¸å¿…å’Œç§»é™¤çš„å­—ç¬¦ç›¸åŒã€‚ä½†æ˜¯ï¼Œå¿…é¡»åœ¨æ¯ä¸€ç§’é’Ÿéƒ½æ‰§è¡Œ ä¸¤ç§ æ“ä½œã€‚

è¿”å›å°† word æ¢å¤åˆ°å…¶ åˆå§‹ çŠ¶æ€æ‰€éœ€çš„ æœ€çŸ­ æ—¶é—´ï¼ˆè¯¥æ—¶é—´å¿…é¡»å¤§äºé›¶ï¼‰ã€‚

 

ç¤ºä¾‹ 1ï¼š

è¾“å…¥ï¼šword = "abacaba", k = 3
è¾“å‡ºï¼š2
è§£é‡Šï¼š
ç¬¬ 1 ç§’ï¼Œç§»é™¤ word çš„å‰ç¼€ "aba"ï¼Œå¹¶åœ¨æœ«å°¾æ·»åŠ  "bac" ã€‚å› æ­¤ï¼Œword å˜ä¸º "cababac"ã€‚
ç¬¬ 2 ç§’ï¼Œç§»é™¤ word çš„å‰ç¼€ "cab"ï¼Œå¹¶åœ¨æœ«å°¾æ·»åŠ  "aba" ã€‚å› æ­¤ï¼Œword å˜ä¸º "abacaba" å¹¶æ¢å¤åˆ°å§‹çŠ¶æ€ã€‚
å¯ä»¥è¯æ˜ï¼Œ2 ç§’æ˜¯ word æ¢å¤åˆ°å…¶åˆå§‹çŠ¶æ€æ‰€éœ€çš„æœ€çŸ­æ—¶é—´ã€‚
ç¤ºä¾‹ 2ï¼š

è¾“å…¥ï¼šword = "abacaba", k = 4
è¾“å‡ºï¼š1
è§£é‡Šï¼š
ç¬¬ 1 ç§’ï¼Œç§»é™¤ word çš„å‰ç¼€ "abac"ï¼Œå¹¶åœ¨æœ«å°¾æ·»åŠ  "caba" ã€‚å› æ­¤ï¼Œword å˜ä¸º "abacaba" å¹¶æ¢å¤åˆ°åˆå§‹çŠ¶æ€ã€‚
å¯ä»¥è¯æ˜ï¼Œ1 ç§’æ˜¯ word æ¢å¤åˆ°å…¶åˆå§‹çŠ¶æ€æ‰€éœ€çš„æœ€çŸ­æ—¶é—´ã€‚
ç¤ºä¾‹ 3ï¼š

è¾“å…¥ï¼šword = "abcbabcd", k = 2
è¾“å‡ºï¼š4
è§£é‡Šï¼š
æ¯ä¸€ç§’ï¼Œæˆ‘ä»¬éƒ½ç§»é™¤ word çš„å‰ 2 ä¸ªå­—ç¬¦ï¼Œå¹¶åœ¨ word æœ«å°¾æ·»åŠ ç›¸åŒçš„å­—ç¬¦ã€‚
4 ç§’åï¼Œword å˜ä¸º "abcbabcd" å¹¶æ¢å¤åˆ°åˆå§‹çŠ¶æ€ã€‚
å¯ä»¥è¯æ˜ï¼Œ4 ç§’æ˜¯ word æ¢å¤åˆ°å…¶åˆå§‹çŠ¶æ€æ‰€éœ€çš„æœ€çŸ­æ—¶é—´ã€‚
æç¤ºï¼š
1 <= word.length <= 105 
1 <= k <= word.length
wordä»…ç”±å°å†™è‹±æ–‡å­—æ¯ç»„æˆã€‚
```

ä»£ç :

```c++
class Solution {
public:
    int minimumTimeToInitialState(string word, int k) {
        int z[100010];
        memset(z,0,sizeof z);
        function<void(void)> get_z = [&](){
            string s = "*" + word;
            z[1] = s.size() - 1;
            for(int i = 2, l, r= 0; i <= s.size();i++){
                if(i <= r) z[i] = min(r - i + 1, z[i - l + 1]);
                while(s[1 + z[i]] == s[i + z[i]]) z[i]++;
                if(i+z[i]-1 > r) r = i + z[i] -1, l = i;
            }
        };
        get_z();
        int mi = (word.size() + k - 1)/k;
        int cnt = 1;
        for(int i = k; i < word.size(); i+=k){
            if(z[i + 1] + i >= word.size()){
                mi = min(cnt,mi);
            }
            cnt++;
        }
        return mi;
    }
};
```



###  7.Manacher(é©¬æ‹‰è½¦)

é©¬æ‹‰è½¦ç®—æ³• å¯ä»¥åœ¨O(n)çš„æ—¶é—´å†…æ±‚å‡ºä¸€ä¸ªå­—ç¬¦ä¸²ä¸­çš„æœ€é•¿å›æ–‡ä¸²,æˆ‘ä»¬å¯ä»¥æ±‚å‡ºæœ€é•¿å›æ–‡åŠå¾„

![image-20240201213600348](img/image-20240201213600348.png)



#### 1.æ¦‚å¿µ

![image-20240201211727315](img/image-20240201211727315.png)

#### 2.ç®—æ³•æµç¨‹

![image-20240201212307990](img/image-20240201212307990.png)

#### 3.ä»£ç 

```c++
int ma = 0;
void get_d(string s){
	//æ”¹é€ ä¸²
	string n_s = "&"; //åŠ å…¥å¤´å“¨å…µ,æ–¹ä¾¿æ¯”è¾ƒ
	for(int i = 0 ; i < s.size(); i++){
		n_s+='#';
		n_s+=s[i];
	} 
	n_s+="#%";//æœ«å°¾ä¹Ÿå¾—æœ‰å ä½ç¬¦,å“¨å…µ
	int n = n_s.size() - 1; //æœ€åä¸€ä¸ªå“¨å…µä¸è¦
	vector<int> d(n+1,0); //å¼€åŠ¨æ€æ•°ç»„é˜²æ­¢å‡ºé”™ 
	d[1] = 1; 
	for(int i = 2,l,r = 1; i <= n; i++){
		if(i <= r) d[i] = min(r - i + 1, d[r - i + l]); //åˆ¤æ–­æ˜¯å¦åœ¨ç›’å­å†… 
		while(n_s[i + d[i]] == n_s[i-d[i]]) d[i]++; //æš´åŠ›å›æ–‡ä¸²é•¿åº¦ 
		if(i+d[i]-1>r) l = i - d[i] + 1, r = i+  d[i] - 1; //æ›´æ–°è¾¹ç•Œ,+1 -1 æ˜¯å»æ‰ä¸­é—´é‚£ä¸ªä½ç½®æœ¬èº« 
		ma = max(d[i],ma); //è·å–æœ€é•¿é•¿åº¦ æœ€åæœ€é•¿å›æ–‡ä¸²çš„é•¿åº¦å°±æ˜¯ma-1; 
	} 
	 
}
```

#### 4.ä¾‹é¢˜

##### [Problem - 4513 (hdu.edu.cn)](https://acm.hdu.edu.cn/showproblem.php?pid=4513)

ä»£ç 

```c++
int get_d(vector<int> v){
	int ma = 0;
	vector<int> nv;
	nv.push_back(-111);
	for(int i = 0; i < v.size();i++){
		nv.push_back(0);
		nv.push_back(v[i]);
	} 
	nv.push_back(0);
	nv.push_back(-999);
	int n = nv.size()-1;
	vector<int> d(n+1,1);
	d[1] = 1;
	for(int i = 2, l,r = 1; i <= n; i++){
		if(i <= r) d[i] = min(d[l + r - i], r - i + 1);
		while(nv[i + d[i]] == nv[i - d[i]] && (!nv[i - d[i]] || nv[i - d[i]] <= nv[i - d[i] + 2])) d[i]++;
		if(i + d[i] - 1 > r) r = i+d[i] - 1, l = i-d[i]+1;
		ma = max(ma,d[i]);
	}
	return ma;
	
}

void solve(){
	int n;
	cin >> n;
	vector<int> v(n,0);
	for(int i = 0; i < n; i++) cin >> v[i];
	
	 cout << get_d(v) - 1<<endl;

}
```

##### [B-å°Açš„å›æ–‡ä¸²_ç‰›å®¢å°ç™½æœˆèµ›13 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/549/B)

ä»£ç :

```c++
int ma = 0;
int d[200000];
void manacher(string s){
    memset(d,0,sizeof d);
	string ns = "&";
	for(int i = 0; i < s.size(); i++){
		ns+="#";
		ns+=s[i];
	}
	ns+="#*";
	d[1] = 1;
	int n = ns.size() - 1;
	for(int i = 2,l,r = 1; i <= n; i++){
		if(i <= r) d[i] = min(r - i + 1,d[r - i + l]);
		while(ns[i + d[i]] == ns[i - d[i]]) d[i]++;
		if(i + d[i] - 1 > r) r = i+d[i]-1,l =i-d[i]+1;
		ma = max(d[i],ma); 
	}
	 
} 
void solve(){
	string s;
	cin >> s;
    manacher(s);
	for(int i = 0; i < s.size(); i++){
        string b ;
        for(int j = 1;j < s.size();j++) b += s[j] ;
        b += s[0] ;
        s = b;
		manacher(s);
	}
	cout << ma - 1;
}

```

### 8.ACè‡ªåŠ¨æœº

#### 1.æ¦‚å¿µ

![1706872737508](img/1706872737508.png)

#### 2.ç®—æ³•æµç¨‹

å»ºacè‡ªåŠ¨æœº

![image-20240202194954969](img/image-20240202194954969.png)

æŸ¥è¯¢

![image-20240202195127783](img/image-20240202195127783.png)

#### 3.ä»£ç 

```c++
const int N = 2000005;

int ch[N][26];
int cnt[N];
int tot; 
//å­—å…¸æ ‘ 
void insert(string s){
	int p = 0;//0ä¸ºæ ¹
	for(int i = 0; i < s.size(); i++){
		int ed = s[i] - 'a';
		if(!ch[p][ed]) ch[p][ed] = ++tot;
		p = ch[p][ed];
	}
	cnt[p]++;
}
int ne[N];
void bulid(){
	//å»ºacè‡ªåŠ¨æœº 
	queue<int> q;
	for(int i = 0; i < 26; i++){
		if(ch[0][i]) q.push(ch[0][i]);
	} 
	while(!q.empty()){
		int u = q.front();q.pop();
		for(int i = 0; i < 26; i++){
			int v = ch[u][i];
			if(v) ne[v] = ch[ne[u]][i],q.push(v);
			else ch[u][i] = ch[ne[u]][i];
		}
	}
}
int query(string s){
	//æŸ¥è¯¢ 
	int ans = 0;
	for(int k = 0, p = 0; k < s.size();k++){
		p = ch[p][s[k] - 'a'];
		for(int j = p; j&&~cnt[j];j=ne[j]){
			ans+=cnt[j],cnt[j] = -1;
		}
	}
	return ans;
}
void solve(){
	int n;
	cin >> n;
	for(int i = 0; i < n; i++){
		string s2;
		cin >> s2;
		insert(s2);
	}
	string s;
	cin >> s;
	bulid();
	cout << query(s);

}
```

#### 4.æ—¶é—´å¤æ‚åº¦

â€‹	O(26n + m)

### 9.åç¼€æ•°ç»„

![image-20240708141132356](img/image-20240708141132356.png)

æ¨¡ç‰ˆ

```c++
int wa[N],wb[N],wv[N],wss[N],rak[N],height[N],cal[N],n,sa[N];
char s[N];
int cmp(int *r,int a,int b,int l)
{return r[a]==r[b]&&r[a+l]==r[b+l];}
void da(int *r,int *sa,int n,int M) {
     int i,j,p,*x=wa,*y=wb,*t;
     for(i=0;i<M;i++) wss[i]=0;
     for(i=0;i<n;i++) wss[x[i]=r[i]]++;
     for(i=1;i<M;i++) wss[i]+=wss[i-1];
     for(i=n-1;i>=0;i--) sa[--wss[x[i]]]=i;
     for(j=1,p=1;p<n;j*=2,M=p) {
        for(p=0,i=n-j;i<n;i++) y[p++]=i;
        for(i=0;i<n;i++) if(sa[i]>=j) y[p++]=sa[i]-j;
        for(i=0;i<n;i++) wv[i]=x[y[i]];
        for(i=0;i<M;i++) wss[i]=0;
        for(i=0;i<n;i++) wss[wv[i]]++;
        for(i=1;i<M;i++) wss[i]+=wss[i-1];
        for(i=n-1;i>=0;i--) sa[--wss[wv[i]]]=y[i];
        for(t=x,x=y,y=t,p=1,x[sa[0]]=0,i=1;i<n;i++)
        x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;
     }
     return;
}
void calheight(int *r,int *sa,int n) {
     int i,j,k=0;
     for(i=1;i<=n;i++) rak[sa[i]]=i;
     for(i=0;i<n;height[rak[i++]]=k)
     for(k?k--:0,j=sa[rak[i]-1];r[i+k]==r[j+k];k++);
     for(int i=n;i;i--)rak[i]=rak[i-1],sa[i]++;
}
```

ä½¿ç”¨æ–¹æ³•

```c++
for(int i=1;i<=n;i++) cal[i]=s[i];
cal[n+1]=0;
da(cal+1,sa,n+1,200);
calheight(cal+1,sa,n);
```

æ ·æ¿

```c++
string s;
cin >> s;
int n = s.size();
s = " " + s;
int pos = n +1;
for(int i = n;i >= 1;i--){
    if(s[i] == pp){
        pos = i;
    }
    nex[i] = pos;
}
for(int i = 1;i<=n;i++) cal[i] = s[i];
cal[n + 1] = 0;
da(cal + 1,sa,n+1,150);
calheight(cal+1,sa,n);
```



## <a name = "byp">ä¸ƒ åšå¼ˆç¯‡</a>

**èƒ½åˆ°è¾¾å¿…è´¥æ€çš„çŠ¶æ€æ˜¯å¿…èƒœæ€ï¼Œåªèƒ½åˆ°è¾¾å¿…èƒœæ€çš„çŠ¶æ€æ˜¯å¿…è´¥æ€**

### 1.NIMåšå¼ˆ

![image-20240203164257289](img/image-20240203164257289.png)

## <a name = "zhsxp">å…« ç»„åˆæ•°å­¦</a>

### 1.ç»„åˆæ•°

**å…¬å¼1:**C(n,m) = C(n - 1,m) + C(n - 1,m - 1);

**ä»£ç :**

```c++
int c[2001][2001];
int mod = 1e9+7;
void get_c(){
	for(int i = 0; i < 2001; i++) c[i][0] = 1;
	for(int i = 1; i < 2001; i++){
		for(int j = 1;j <= i;j++){
			c[i][j] = (c[i - 1][j] + c[i-1][j-1])%mod; //æ•°å¤§çš„æ—¶å€™è¦mod
		}
	}
}
```

**å…¬å¼2:**C(n,m) = n!/(n-m)!*m!

### 2.é”™æ’

é”™æ’å…¬å¼:$d[i] = (i - 1)(d[i - 1] + dp[i - 2])$

$d[1] = 0,d[2] = 1$

## <a name = "brdmmb">ä¹ æœ¬äººå¸¸ç”¨ä»£ç æ¨¡ç‰ˆ</a>

```c++
#include<bits/stdc++.h>
using namespace std;
#define BUFF ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
#define int long long
typedef unsigned long long ULL;
typedef long long ll;
int p[1222222]; //ç­›é€‰ç´ æ•°
void as(){
	p[0] = p[1] = p[2] = p[3] = 0;
	for(int i = 2; i <= (1e6+10);i++){
		if(p[i] == 0){
			for(int j = i*2;j<=1e6+10;j+=i){
				p[j]++;
			}
		}
	}
}
ll powerMod(ll x, ll n, ll mod){ //å¿«é€Ÿå¹‚
    ll ans = 1;
    while (n > 0){
        if  (n & 1)
            ans = (ans * x) % mod;
        x = (x * x) % mod;
        n >>= 1;
    }
    return ans;
}
const int N = 100005;


void solve(){


}


signed main(){
	BUFF;
	int times = 1;
	//cin >> times;
	while(times--){
		solve();
	}
	return 0;
}

```

## <a name = "bszj">å.æ¯”èµ›æ€»ç»“</a>

### 1.2024å¹´2æœˆ

#### 1.ioi

å¤©æ¢¯èµ›æ—¶é—´å¤ªç´§,ä»l2å¼€å§‹è¦å…ˆæŒ‘å¥½åšçš„,ä¸ç„¶åé¢æ—¶é—´æ¥ä¸åŠ,å¯¼è‡´ä¼šåšçš„æ²¡åšå‡º,å®åœ¨æœ‰æ—¶é—´å¯ä»¥å†²å†²l3,å¤©æ¢¯èµ›é‡å¤ªå¤§,æœ‰äº›bugå¯¼è‡´é¢˜é¢æ²¡æ‹¿æ»¡åˆ†,åº”è¯¥å…ˆè·³è¿‡,è€Œä¸æ˜¯æµªè´¹æ—¶é—´æ­»æ‰¾,åº”è¯¥è·³è¿‡,ç„¶åæœ€åå»æ‰¾bug,å¤šå¼€é¢˜è€Œä¸æ˜¯å¤šæ‰¾bug.å¤©æ¢¯èµ›,ç»†èŠ‚æ‰£çš„æŒºå¤šçš„,å†™çš„æ—¶å€™å°±åº”è¯¥æ³¨æ„ç»†èŠ‚

#### **2.oi**

å†™oiå¿ƒé‡Œæ²¡åº•,æˆ‘æ˜¯å…¨å†™ä¸€éæš´åŠ›,æœ€åå†å›å¤´å†å»ä¼˜åŒ–ä»£ç ,æŠŠèƒ½æ‹¿çš„åˆ†æ‹¿äº†,æ‰¾å¯¹ç­¾åˆ°é¢˜,æ¨¡æ‹Ÿå¿…é¡»å¾—æ‹¿æ»¡åˆ†,éš¾é¢˜dfs,ä¸­ç­‰é¢˜å…ˆdfs,ååœ¨ä¼˜åŒ–,å¤šå¼€é¢˜å¤šdfs å›è¿‡å¤´æ¥ä¼˜åŒ–,oiå†™åˆ°äº†ä¸ªæ ‘,ä»¥ä¸ºæ˜¯æ¢æ ¹dp,å…¶å®æœ‰æ—¶å€™å˜åŒ–ä¸€ä¸‹æ€è·¯å°±è¡Œ,ä¸èƒ½æ€ç»´å®šå¼

### 1.2024å¹´4æœˆ

#### 1.çœèµ›

è´¥åœ¨äº†æ•°å­¦ä¸æ²¡çœ‹æ•°æ®èŒƒå›´,è¿˜æœ‰è·Ÿæ¦œå‡ºç°é—®é¢˜

çœèµ›é—®é¢˜å¾ˆå¤š æ€»ç»“äº†ä¸€ä¸‹ä¸»è¦åˆ†ä¸ºä¸‰ç‚¹

1.æ¦œå¯èƒ½æ˜¯æ­ªçš„,æœ‰ä¸€é“æ€ç»´ä¸€é“dfsä¸€é“bfsæ²¡å¼€,ç­¾å®Œåˆ°,å°±åœ¨çœ‹ä¸€é“äºŒåˆ†å›¾äº†,åšå‡ºçš„äººå¤šçš„é¢˜ä¸ä¸€å®šæ˜¯èƒ½åšçš„,æœ‰å¯èƒ½æ¦œæ˜¯æ­ªçš„,è™½ç„¶æœ‰ç‚¹å°æ¦‚ç‡,ä»¥åè¿˜æ˜¯è¦æ³¨æ„,ä¸€é“é¢˜æ²¡æœ‰æ€è·¯,å°±æ¢é¢˜å¼€,è¦è‡ªä¿¡ä¸€ç‚¹,åˆ«äººæ²¡å¼€å¯èƒ½æ˜¯æ²¡çœ‹é¢˜ä¸ä¸€å®šæ˜¯é¢˜å¤ªéš¾

2.ç­¾åˆ°é¢˜ç¿»è½¦,ä¸»è¦æ˜¯æ²¡çœ‹æ•°æ®é‡,æ˜æ˜æ˜¯n^2 ä¸¤ä¸ªforåµŒå¥—ç®€ç®€å•å•çš„é—®é¢˜,å´å»åšsortçš„nlognè§£æ³•,è¢«nameé‡å¤æäº†ä¸€æ³¢,æ•°æ®é‡2000å®Œå…¨æš´åŠ›,ä¸èƒ½å¤ªç´§å¼ ,è„‘å­æ™•äº†,å¯¼è‡´ç­¾åˆ°ç­¾åŠå¤©,

3.æ•°å­¦å¼±,çœ‹åˆ°æ•°å­¦çš„ä¸‰è§’å½¢æ‰¾è§„å¾‹å…¬å¼é¢˜,æˆ‘è¿™æ–¹é¢è®­ç»ƒçš„å°‘,å¯¼è‡´æœ‰ç‚¹å¼±,ä¸èƒ½å¸®é˜Ÿå‹è§£å†³m,å¯¼è‡´mæœ€åæ²¡æœ‰åšå‡ºæ¥,åˆ«çš„é¢˜ä¹Ÿæ²¡æœ‰å¼€å‡ºæ¥,äºŒåˆ†å›¾æ²¡å­¦ç¡®å®å¯æƒœ,é‚£æ—¶å€™é€‰æ‹©å…ˆæå„ç§dpå†å­¦äºŒåˆ†å›¾,äºŒåˆ†å›¾é‚£é¢˜æ„æ€éƒ½ç¿»è¯‘å‡ºæ¥äº†,ä½†æ˜¯æ²¡æœ‰ç†è§£æ€ä¹ˆåš.

æ€»ç»“ æé«˜æ•°å­¦èƒ½åŠ›,äºŒåˆ†å›¾ç½‘ç»œæµå­¦èµ·æ¥,è¿˜æœ‰çœ‹æ•°æ®é‡è¡Œäº‹,å°±ç®—æ¦œä¸Šçš„é¢˜æœ‰äº›é¢˜æ²¡äººå¼€,ä½†ä¹Ÿè¦çœ‹,ä¸è¦**æ— è„‘**è·Ÿæ¦œ

è¿˜æœ‰æé«˜é˜Ÿå‹ç†Ÿæ‚‰åº¦,è¿˜æ˜¯å¤šè®¨è®º!!!

#### 2.å¤©æ¢¯èµ›

å¤©æ¢¯èµ›æ€»ä½“æ‰“çš„è¿˜è¡Œ,è¢«è®¾å¤‡å¡äº†å¼€å±€åŠä¸ªå°æ—¶,èŠ±äº†ä¸¤ä¸ªåŠå°æ—¶æ‹¿äº†214åˆ†,æˆ–è®¸æ—¶é—´å¤šä¸€ç‚¹èƒ½æ‹¿é“¶,ä¸‹æ¬¡çŸ¥é“å•¦,æ ¡å›­ç½‘æ¯”çƒ­ç‚¹ç¨³å®š,çƒ­ç‚¹ä¸€ç›´æ–­,æ ¡å›­ç½‘åé¢å¼€äº†å°±æ²¡æ–­è¿‡.

æœ‰ä¸€äº›ç»†èŠ‚è¿˜æ˜¯æ²¡æœ‰æ³¨æ„,l1è¢«æ‰£äº†ä¸¤åˆ†,è¦æ˜¯æ³¨æ„ä¸€ä¸‹ç»†èŠ‚æˆ–è®¸èƒ½æ‹¿é“¶å§,

å¤©æ¢¯èµ›æ‰“çš„è¿˜è¡Œ,æ²¡å•¥æ€»ç»“çš„,æ€»çš„æ¥è¯´å¤šåˆ·é¢˜ä¿æŒåœ¨å›¢ä½“é‡‘ç‰Œçº¿210åˆ†å³å¯

#### 3.è“æ¡¥æ¯

å¾ˆéš¾å•Š,ä¸€å¦‚æ—¢å¾€çš„ä¸ä¼šæœŸæœ›,æœŸæœ›é‚£é¢˜å¡«ç©ºé¢˜ç›´æ¥æ‘†çƒ‚,å…¶ä»–èƒ½æš´åŠ›çš„æš´åŠ›,å­—å…¸æ ‘è¿ªæ°æ–¯ç‰¹æ‹‰å¹¶æŸ¥é›†ä¸‰é¢˜å†™çš„å¾ˆå®Œç¾,å…¶ä»–åŸºæœ¬ä¸Šåœ¨æš´åŠ›éª—åˆ†,

**é—®é¢˜ä½“ç°:**å¾ˆå¤šæ¿å­ä¸ç†Ÿ,å¥½ä¹…æ²¡å†™å­—å…¸æ ‘äº†,è€ƒè¯•çš„æ—¶å€™å‡ ä¹æ˜¯æ‰‹æ¨æ‰‹èŠ±å­—å…¸æ ‘,åŠå…¶è‰°éš¾,å­—å…¸æ ‘é‚£é¢˜è™½ç„¶10åˆ†ä½†æˆ‘åšäº†2ä¸ªå°æ—¶,åšå‰é¢çš„é¢˜ç›´æ¥æ±—æµæµƒèƒŒäº†,è¿˜æ˜¯æ¿å­ä¸ç†Ÿç»ƒ,ä»Šå¹´ç«Ÿç„¶è¿˜è€ƒè™‘çº¿æ®µæ ‘å¥½åƒ,å¬ç¾¤å‹è¯´,æˆ‘çº¿æ®µæ ‘å†™çš„ä¸å¤ªè¡Œ,åŸºæœ¬ä¸Šåªä¼šæ¿å­,è¿™ä¹Ÿæ˜¯æˆ‘çš„é—®é¢˜ä¹‹ä¸€.

**è¦æå‡çš„:**å„ä¸ªæ¿å­ä¸èƒ½ä¾èµ–cv,è¦è®°å¾—æ€ä¹ˆå†™,è¿˜æœ‰æ¦‚ç‡æ•°å­¦æœŸæœ›å­¦èµ·æ¥,åŠ¨æ€è§„åˆ’å­¦èµ·æ¥.

### 1.2024å¹´å…­æœˆ

```
ç™¾åº¦ä¹‹æ˜Ÿç¬¬ä¸€åœº
dpæ²¡åšå‡ºæ¥,æ²¡å¼€æ»šåŠ¨æ•°ç»„,çŸ¥é“æ˜¯dpä½†æ˜¯åé¢å»è®°å¿†åŒ–æœ,ç»“æœä¸€ç›´waä¸€ç›´mle,èµ›æ—¶ç´§å¼ ,æ²¡æœ‰æ€è€ƒå…¨é¢,ç©ºé—´ä¸å¤Ÿåº”è¯¥è€ƒè™‘æ»šåŠ¨æ•°ç»„,ä¸€ä¸ªå¾ˆç®€å•çš„dpå°±æ˜¯æš´åŠ›æƒ³,æ²¡åšå‡ºæ¥å¾ˆé—æ†¾
é€†å…ƒé¢˜æ²¡æœ‰å¤´ç»ª,æ²¡æƒ³åˆ°æ˜¯ç®—è´¡çŒ®,å…¶å®ä¸éš¾,åº”è¯¥å¤šè¯•è¯•çš„æœ‰äº›é¢˜
```

```
ç™¾åº¦ä¹‹æ˜Ÿç¬¬äºŒåœº
ç¬¬ä¸€é¢˜çœ‹ç€å¾ˆç®€å•ä¸€çœ¼å·®åˆ†,å–ä¸­ä½æ•°çš„æ—¶å€™å±…ç„¶å¿˜è®°æ’åº,å¯¼è‡´waäº†
ç¬¬äºŒé¢˜è¿˜æ˜¯å› ä¸ºç´§å¼ ,æ²¡æœ‰å¥½å¥½è€ƒè™‘ç»†èŠ‚,æ ·ä¾‹è¿‡äº†å°±ä¸€ç›´äº¤,ç„¶åä¸€ç›´wa,52åˆ†é’Ÿåšå‡ºæ¥çš„,ä½†æ˜¯waäº†9å‘,ä»¥åç­–ç•¥è¿˜å¾—æ˜¯å°‘waå¤šæƒ³,ä¸èƒ½å¤ªç€æ€¥
```

